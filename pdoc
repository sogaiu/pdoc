#! /usr/bin/env janet

(comment import ./argv :prefix "")
(def av/arg-data
  {"--bash-completion" true
   "--fish-completion" true
   "--zsh-completion" true
   "--raw-all" true
   "--doc" "-d"
   "--help" "-h"
   "--quiz" "-q"
   "--usage" "-u"})

(def av/shorts-table
  (tabseq [[full short] :pairs av/arg-data
           :when short]
    short full))

(defn av/opt-to-keyword
  [opt-str]
  (def full-opt-str (get av/shorts-table opt-str opt-str))
  (when (not (string/has-prefix? "--" full-opt-str))
    (break (string/format "Unknown short option: %s" opt-str)))
  (when (not (get av/arg-data full-opt-str))
    (break (string/format "Unknown option: %s" opt-str)))
  (keyword (string/slice full-opt-str 2)))

(defn av/parse-argv
  [argv]
  (def opts @{})
  (def rest @[])
  (def errs @[])
  (def argc (length argv))
  #
  (when (> argc 1)
    (var i 1)
    (while (< i argc)
      (def arg (get argv i))
      (if (string/has-prefix? "-" arg)
        (let [res (av/opt-to-keyword arg)]
          (cond
            (string? res)
            (array/push errs res)
            #
            (keyword? res)
            (put opts res true)
            #
            (array/push errs
                        (string/format "unexpected type: %n"
                                       (type res)))))
        (array/push rest arg))
      (++ i)))
  #
  [opts rest errs])


(comment import ./completion :prefix "")
(def compl/bash-completion
  ``
  _pdoc_specials() {
      COMPREPLY=( $(compgen -W "$(pdoc --raw-all)" -- ${COMP_WORDS[COMP_CWORD]}) );
  }
  complete -F _pdoc_specials pdoc
  ``)

(def compl/fish-completion
  ``
  function __pdoc_complete_specials
    if not test "$__pdoc_specials"
      set -g __pdoc_specials (pdoc --raw-all)
    end

    printf "%s\n" $__pdoc_specials
  end

  complete -c pdoc -a "(__pdoc_complete_specials)" -d 'specials'
  ``)

(def compl/zsh-completion
  ``
  #compdef pdoc

  _pdoc() {
      local matches=(`pdoc --raw-all`)
      compadd -a matches
  }
  
  _pdoc "$@"
  ``)

(defn compl/maybe-handle-dump-completion
  [opts]
  # this makes use of the fact that print returns nil
  (not
    (cond
      (opts :bash-completion)
      (print compl/bash-completion)
      #
      (opts :fish-completion)
      (print compl/fish-completion)
      #
      (opts :zsh-completion)
      (print compl/zsh-completion)
      #
      true)))


(comment import ./data :prefix "")
(def data/names
  @{
"_all-the-names"
````````
#
# Primitive Patterns
#   Integer (..., -1, 0, 1, ...)
#   range                  =  (range r1 ?r2 ... ?rn)
#   set                    =  (set chars)
#   String ("...")
#   Buffer (@"...")
#   Boolean (true, false)
#
# Combining Patterns
#   any                    =  (any patt)
#   at-least               =  (at-least n patt)
#   at-most                =  (at-most n patt)
#   backmatch              =  (backmatch ?tag)
#   between (opt, ?)       =  (between min max patt)
#   choice (+)             =  (choice patt-1 patt-2 ...)
#   if                     =  (if cond patt)
#   if-not                 =  (if-not cond patt)
#   look (>)               =  (look offset ?patt)
#   not (!)                =  (not patt)
#   repeat (0, 1, 2, ...)  =  (repeat n patt)
#   sequence (*)           =  (sequence patt-1 patt-2 ...)
#   some                   =  (some patt)
#   split                  =  (split sep patt)
#   sub                    =  (sub window-patt patt)
#   thru                   =  (thru patt)
#   til                    =  (til sep patt)
#   to                     =  (to patt)
#
# Captures
#   accumulate (%)         =  (accumulate pat ?tag)
#   argument               =  (argument n ?tag)
#   backref (->)           =  (backref prev-tag ?tag)
#   capture (<-, quote)    =  (capture patt ?tag)
#   cmt                    =  (cmt patt fun ?tag)
#   cms                    =  (cms patt fun ?tag)
#   column                 =  (column ?tag)
#   constant               =  (constant k ?tag)
#   drop                   =  (drop patt)
#   error                  =  (error ?patt)
#   group                  =  (group patt ?tag)
#   int                    =  (int n ?tag)
#   int-be                 =  (int-be n ?tag)
#   lenprefix              =  (lenprefix n patt)
#   line                   =  (line ?tag)
#   nth                    =  (nth index patt ?tag)
#   number                 =  (number patt ?base ?tag)
#   only-tags              =  (only-tags patt)
#   position ($)           =  (position ?tag)
#   replace (/)            =  (replace patt subst ?tag)
#   uint                   =  (uint n ?tag)
#   uint-be                =  (uint-be n ?tag)
#   unref                  =  (unref rule ?tag)
#
# Other Patterns
#   debug (??)             =  (debug)
#
# Built-ins
#   :a                     =  (range "AZ" "az")
#   :d                     =  (range "09")
#   :h                     =  (range "09" "AF" "af")
#   :s                     =  (set " \0\f\n\r\t\v")
#   :w                     =  (range "09" "AZ" "az")
#   :A                     =  (if-not :a 1)
#   :D                     =  (if-not :d 1)
#   :H                     =  (if-not :h 1)
#   :S                     =  (if-not :s 1)
#   :W                     =  (if-not :w 1)
#   :a+                    =  (some :a)
#   :d+                    =  (some :d)
#   :h+                    =  (some :h)
#   :s+                    =  (some :s)
#   :w+                    =  (some :w)
#   :A+                    =  (some :A)
#   :D+                    =  (some :D)
#   :H+                    =  (some :H)
#   :S+                    =  (some :S)
#   :W+                    =  (some :W)
#   :a*                    =  (any :a)
#   :d*                    =  (any :d)
#   :h*                    =  (any :h)
#   :s*                    =  (any :s)
#   :w*                    =  (any :w)
#   :A*                    =  (any :A)
#   :D*                    =  (any :D)
#   :H*                    =  (any :H)
#   :S*                    =  (any :S)
#   :W*                    =  (any :W)
#
# Aliases
#   (! patt)               =  (not patt)
#   ($ ?tag)               =  (position ?tag)
#   (% patt ?tag)          =  (accumulate patt ?tag)
#   (* patt-1 ... patt-n)  =  (sequence patt-1 ... patt-n)
#   (+ patt-1 ... patt-n)  =  (choice patt-1 ... patt-n)
#   (-> prev-tag ?tag)     =  (backref prev-tag ?tag)
#   (/ patt subst ?tag)    =  (replace patt subst ?tag)
#   (<- patt ?tag)         =  (capture patt ?tag)
#   (> offset ?patt)       =  (look offset ?patt)
#   (? patt)               =  (between 0 1 patt)
#   (1 patt)               =  (repeat 1 patt)
#   (2 patt)               =  (repeat 2 patt)
#   (3 patt)               =  (repeat 3 patt)
#   ...
#   (opt patt)             =  (between 0 1 patt)
#   (quote patt ?tag)      =  (capture patt ?tag)
#   'patt                  =  (capture patt)
#   (??)                   =  (debug)
#
````````
"_boolean"
````````
(import ../margaret/meg :as peg)

# `true` or `false`

# Equivalent to `0` and `(not 0)` respectively.

(comment

  (peg/match true "")
  # =>
  @[]

  (peg/match false "")
  # =>
  nil

  (peg/match true "a")
  # =>
  @[]

  (peg/match false "a")
  # =>
  nil

  (peg/match '(choice "a" true) "a")
  # =>
  @[]

  (peg/match '(choice "a" true) "")
  # =>
  @[]

  (peg/match '(choice "a" false) "a")
  # =>
  @[]

  (peg/match '(choice "a" false) "")
  # =>
  nil

  )
````````
"_buffer"
````````
(import ../margaret/meg :as peg)

# `@"<b>"` -- where <s> is buffer content

# Matches a literal buffer, and advances a corresponding number of characters.

(comment

  (peg/match @"cat" "cat")
  # =>
  @[]

  (peg/match @"cat" "cat1")
  # =>
  @[]

  (peg/match @"" "")
  # =>
  @[]

  (peg/match @"" "a")
  # =>
  @[]

  (peg/match @"cat" "dog")
  # =>
  nil

  )
````````
"_compile"
````````
(import ../margaret/meg :as peg)

(comment

  (type (peg/compile ~(capture 1)))
  # =>
  :function

  (peg/match
    (peg/compile ~(capture 1))
    "xy"
    0)
  # =>
  @["x"]

  (type (comptime (peg/compile ~(capture 1))))
  # =>
  :function

  (peg/match
    (comptime
      (peg/compile ~(capture 1)))
    "xy"
    0)
  # =>
  @["x"]

  (string/has-prefix?
    "start "
    (try
      (let [compiled-peg (peg/compile ~(capture 1))]
        (peg/match compiled-peg "xy" -4))
      ([e] e)))
  # =>
  true

  )
````````
"_dictionary"
````````
(import ../margaret/meg :as peg)

# `{:main <rule> ...}`

# or

# `@{:main <rule> ...}`

# where <rule> is a peg (see below for ...)

# The feature that makes PEGs so much more powerful than pattern
# matching solutions like (vanilla) regex is mutual recursion.

# To do recursion in a PEG, you can wrap multiple patterns in a
# grammar, which is a Janet dictionary (i.e. a struct or a table).

# The patterns must be named by keywords, which can then be used in
# all sub-patterns in the grammar.

# Each grammar, defined by a dictionary, must also have a main rule,
# called `:main`, that is the pattern that the entire grammar is
# defined by.

(comment

  (peg/match '{:main 1} "a")
  # =>
  @[]

  (peg/match '{:main :fun
               :fun 1}
             "a")
  # =>
  @[]

  (peg/match ~{:main (some :fun)
               :fun (choice :play :relax)
               :play "1"
               :relax "0"}
             "0110111001")
  # =>
  @[]

  )

(comment

  (def my-grammar
    '{:a (* "a" :b "a")
      :b (* "b" (+ :a 0) "b")
      :main (* "(" :b ")")})

  # alternative expression of `my-grammar`
  (def my-grammar-alt
    '@{# :b wrapped in parens
       :main (sequence "("
                       :b
                       ")")
       # :a or nothing wrapped in lowercase b's
       :b (sequence "b"
                    (choice :a 0)
                    "b")
       # :b wrapped in lowercase a's
       :a (sequence "a"
                    :b
                    "a")})

  # simplest match
  (peg/match my-grammar-alt "(bb)")
  # =>
  @[]

  # next simplest match
  (peg/match my-grammar-alt "(babbab)")
  # =>
  @[]

  # non-match
  (peg/match my-grammar-alt "(baab)")
  # =>
  nil

  (all |(deep= (peg/match my-grammar $)
               (peg/match my-grammar-alt $))
       ["(bb)" "(babbab)" "(baab)"])
  # =>
  true

  )
````````
"_integer"
````````
(import ../margaret/meg :as peg)

# `<n>` -- where <n> is an integer

# For n >= 0, try to match n characters, and if successful, advance
# that many characters.

# For n < 0, matches only if there aren't |n| characters, and do not
# advance.

# For example, -1 will match the end of a string because the length of
# the empty string is 0, which is less than 1 (i.e. |-1| = 1 and there
# aren't that many characters).

(comment

  (peg/match 0 "")
  # =>
  @[]

  (peg/match 1 "")
  # =>
  nil

  (peg/match 1 "a")
  # =>
  @[]

  (peg/match 3 "cat")
  # =>
  @[]

  (peg/match 2 "cat")
  # =>
  @[]

  (peg/match 4 "cat")
  # =>
  nil

  (peg/match -1 "")
  # =>
  @[]

  (peg/match -2 "")
  # =>
  @[]

  (peg/match -1 "cat")
  # =>
  nil

  (peg/match -2 "o")
  # =>
  @[]

  )
````````
"_start"
````````
(import ../margaret/meg :as peg)

(comment

  (peg/match ~(capture 1)
             "xy"
             0)
  # =>
  @["x"]

  (peg/match ~(capture 1)
             "xy"
             1)
  # =>
  @["y"]

  (peg/match ~(capture 1)
             "xy"
             2)
  # =>
  nil

  (peg/match ~(capture 1)
             "xy"
             -1)
  # =>
  nil

  (peg/match ~(capture 1)
             "xy"
             -2)
  # =>
  @["y"]

  (peg/match ~(capture 1)
             "xy"
             -3)
  # =>
  @["x"]

  )

(comment

  (string/has-prefix?
    "start "
    (try
      (peg/match ~(capture 1)
                 "xy"
                 3)
      ([e] e)))
  # =>
  true

  (string/has-prefix?
    "start "
    (try
      (peg/match ~(capture 1)
                 "xy"
                 -4)
      ([e] e)))
  # =>
  true

  )
````````
"_string"
````````
(import ../margaret/meg :as peg)

# `"<s>"` -- where <s> is string content

# Matches a literal string, and advances a corresponding number of characters.

(comment

  (peg/match "cat" "cat")
  # =>
  @[]

  (peg/match "cat" "cat1")
  # =>
  @[]

  (peg/match "" "")
  # =>
  @[]

  (peg/match "" "a")
  # =>
  @[]

  (peg/match "cat" "dog")
  # =>
  nil

  )
````````
"accumulate"
````````
(import ../margaret/meg :as peg)

# `(accumulate patt ?tag)`

# Capture a string that is the concatenation of all captures in `patt`.

# `(% patt ?tag)` is an alias for `(accumulate patt ?tag)`

(comment

  (peg/match ~(accumulate (sequence (capture 1)
                                    (capture 1)
                                    (capture 1)))
             "abc")
  # =>
  @["abc"]

  (peg/match ~(sequence (accumulate (sequence (capture "a")
                                              (capture "b"))
                                    :my-tag)
                        (backref :my-tag))
             "abc")
  # =>
  @["ab" "ab"]

  (peg/match ~(accumulate (sequence (capture "a")
                                    (capture "b")
                                    (capture "c")))
             "abc")
  # =>
  @["abc"]

  (peg/match ~(accumulate (sequence (capture "a")
                                    (position)
                                    (capture "b")
                                    (position)
                                    (capture "c")
                                    (position)))
             "abc")
  # =>
  @["a1b2c3"]

  (peg/match ~(% (sequence (capture "a")
                           (capture "b")
                           (capture "c")))
             "abc")
  # =>
  @["abc"]

  (peg/match ~(% (sequence (capture "a")
                           (position)
                           (capture "b")
                           (position)
                           (capture "c")
                           (position)))
             "abc")
  # =>
  @["a1b2c3"]

  )
````````
"any"
````````
(import ../margaret/meg :as peg)

# `(any patt)`

# Matches 0 or more repetitions of `patt`

(comment

  # any with empty string
  (peg/match ~(any "a")
             "")
  # =>
  @[]

  # any
  (peg/match ~(any "a")
             "aa")
  # =>
  @[]

  # any with capture
  (peg/match ~(capture (any "a"))
             "aa")
  # =>
  @["aa"]

  )
````````
"argument"
````````
(import ../margaret/meg :as peg)

# `(argument n ?tag)`

# Captures the nth extra argument to the `match` function and does not advance.

(comment

  (peg/match ~(sequence "abc"
                        (argument 0))
             "abc"
             0
             :smile)
  # =>
  @[:smile]

  (peg/match ~(argument 0) "whatever"
             0
             :zero :one :two)
  # =>
  @[:zero]

  (peg/match ~(argument 2) "whatever"
             0
             :zero :one :two)
  # =>
  @[:two]

  (peg/match ~(sequence (argument 0 :tag)
                        (backref :tag))
             "ignored"
             0
             :smile)
  # =>
  @[:smile :smile]

  )
````````
"at-least"
````````
(import ../margaret/meg :as peg)

# `(at-least n patt)`

# Matches at least n repetitions of patt

(comment

  (peg/match ~(at-least 3 "z")
             "zz")
  # =>
  nil

  (peg/match ~(at-least 3 "z")
             "zzz")
  # =>
  @[]

  )
````````
"at-most"
````````
(import ../margaret/meg :as peg)

# `(at-most n patt)`

# Matches at most n repetitions of patt

(comment

  (peg/match ~(at-most 3 "z") "zz")
  # =>
  @[]

  (peg/match ~(sequence (at-most 3 "z") "z")
             "zzz")
  # =>
  nil

  )
````````
"backmatch"
````````
(import ../margaret/meg :as peg)

# `(backmatch ?tag)`

# If `tag` is provided, matches against the tagged capture.

# If no tag is provided, matches against the last capture, but only if that
# capture is untagged.

# The peg advances if there was a match.

(comment

  (peg/match ~(sequence (capture "a")
                        "b"
                        (capture (backmatch)))
             "aba")
  # =>
  @["a" "a"]

  (peg/match ~(sequence (capture "a" :a)
                        (capture "b")
                        (capture (backmatch)))
             "abb")
  # =>
  @["a" "b" "b"]

  (peg/match ~(sequence (capture "a" :a)
                        (capture "b")
                        (capture (backmatch :a)))
             "aba")
  # =>
  @["a" "b" "a"]

  (peg/match ~(sequence (capture "a" :target)
                        (capture (some "b"))
                        (capture (backmatch :target)))
             "abbba")
  # =>
  @["a" "bbb" "a"]

  (peg/match ~(sequence (capture "a")
                        (capture (some "b"))
                        (capture (backmatch))) # referring to captured "b"s
             "abbba")
  # =>
  nil

  (peg/match ~(sequence (capture "a")
                        (some "b")
                        (capture (backmatch))) # referring to captured "a"
             "abbba")
  # =>
  @["a" "a"]

  )

(comment

  (def backmatcher-1
    '(sequence (capture (any "x") :1)
               "y"
               (backmatch :1)
               -1))

  (peg/match backmatcher-1 "y")
  # =>
  @[""]

  (peg/match backmatcher-1 "xyx")
  # =>
  @["x"]

  (peg/match backmatcher-1 "xxxxxxxyxxxxxxx")
  # =>
  @["xxxxxxx"]

  (peg/match backmatcher-1 "xyxx")
  # =>
  nil

  (peg/match backmatcher-1
             (string "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
                     "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy"))
  # =>
  nil

  (def backmatcher-2
    '(sequence '(any "x")
               "y"
               (backmatch)
               -1))

  (peg/match backmatcher-2 "y")
  # =>
  @[""]

  (peg/match backmatcher-2 "xyx")
  # =>
  @["x"]

  (peg/match backmatcher-2 "xxxxxxxyxxxxxxx")
  # =>
  @["xxxxxxx"]

  (peg/match backmatcher-2 "xyxx")
  # =>
  nil

  (peg/match backmatcher-2
             (string "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
                     "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy"))
  # =>
  nil

  (peg/match backmatcher-2
             (string (string/repeat "x" 1000) "y"))
  # =>
  nil

  (peg/match backmatcher-2
             (string (string/repeat "x" 1000)
                     "y"
                     (string/repeat "x" 1000)))
  # =>
  (array (string/repeat "x" 1000))

  (def longstring-2
    '(sequence (capture (any "`"))
               (any (if-not (backmatch) 1))
               (backmatch)
               -1))

  (peg/match longstring-2 "`john")
  # =>
  nil

  (peg/match longstring-2 "abc")
  # =>
  nil

  (peg/match longstring-2 "` `")
  # =>
  @["`"]

  (peg/match longstring-2 "`  `")
  # =>
  @["`"]

  (peg/match longstring-2 "``  ``")
  # =>
  @["``"]

  (peg/match longstring-2 "``` `` ```")
  # =>
  @["```"]

  (peg/match longstring-2 "``  ```")
  # =>
  nil

  )
````````
"backref"
````````
(import ../margaret/meg :as peg)

# `(backref prev-tag ?tag)`

# Duplicates the last capture with tag `prev-tag`.

# If no such capture exists then the match fails.

# `(-> prev-tag ?tag)` is an alias for `(backref prev-tag ?tag)`

(comment

  (peg/match ~(sequence (capture 1 :a)
                        (backref :a))
             "a")
  # =>
  @["a" "a"]

  (peg/match ~(sequence (capture "a" :target)
                        (backref :target))
             "b")
  # =>
  nil

  (peg/match ~(sequence (capture 1 :a)
                        (backref :a)
                        (capture 1))
             "ab")
  # =>
  @["a" "a" "b"]

  (peg/match ~(sequence (capture "a" :target)
                        (capture "b" :target-2)
                        (backref :target-2)
                        (backref :target))
             "ab")
  # =>
  @["a" "b" "b" "a"]

  (peg/match ~(sequence (capture "a" :target)
                        (-> :target))
             "a")
  # =>
  @["a" "a"]

  (peg/match ~(sequence (capture "a" :target)
                        (capture "b" :target-2)
                        (-> :target-2)
                        (-> :target))
             "ab")
  # =>
  @["a" "b" "b" "a"]

  (peg/match ~(sequence (capture "a" :target)
                        (-> :target))
             "b")
  # =>
  nil

  )
````````
"between"
````````
(import ../margaret/meg :as peg)

# `(between min max patt)`

# Matches between `min` and `max` (inclusive) repetitions of `patt`

# `(opt patt)` and `(? patt)` are aliases for `(between 0 1 patt)`

(comment

  # between
  (peg/match ~(between 1 3 "a")
             "aa")
  # =>
  @[]

  # between matching max
  (peg/match ~(between 0 1 "a")
             "a")
  # =>
  @[]

  # between matching min 0 on empty string
  (peg/match ~(between 0 1 "a")
             "")
  # =>
  @[]

  # between matching 0 occurrences
  (peg/match ~(between 0 8 "b")
             "")
  # =>
  @[]

  # between with sequence
  (peg/match ~(sequence (between 0 2 "c")
                        "c")
             "ccc")
  # =>
  @[]

  # between matched max, so sequence fails
  (peg/match ~(sequence (between 0 3 "c")
                        "c")
             "ccc")
  # =>
  nil

  # opt
  (peg/match ~(opt "a")
             "a")
  # =>
  @[]

  # opt with empty string
  (peg/match ~(opt "a")
             "")
  # =>
  @[]

  (peg/match ~(? "a") "a")
  # =>
  @[]

  (peg/match ~(? "a") "")
  # =>
  @[]

  )

(comment

  # issue 1554 case 1
  (peg/match '(any (> '1)) "abc")
  # =>
  @["a"]

  # issue 1554 case 2
  (peg/match '(any (? (> '1))) "abc")
  # =>
  @["a"]

  # issue 1554 case 3
  (peg/match '(any (> (? '1))) "abc")
  # =>
  @["a"]

  # issue 1554 case 4
  (peg/match '(* "a" (> '1)) "abc")
  # =>
  @["b"]

  # issue 1554 case 5
  (peg/match '(* "a" (? (> '1))) "abc")
  # =>
  @["b"]

  # issue 1554 case 6
  (peg/match '(* "a" (> (? '1))) "abc")
  # =>
  @["b"]

  )
````````
"capture"
````````
(import ../margaret/meg :as peg)

# `(capture patt ?tag)`

# Capture all of the text in `patt` if `patt` matches.

# If `patt` contains any captures, then those captures will be pushed on to
# the capture stack before the total text.

# `(<- patt ?tag)` is an alias for `(capture patt ?tag)`

# `(quote patt ?tag)` is an alias for `(capture patt ?tag)`

# This allows code like `'patt` to capture a pattern

(comment

  (peg/match '(capture 1) "a")
  # =>
  @["a"]

  (peg/match ~(capture "a") "a")
  # =>
  @["a"]

  (peg/match ~(<- "a") "a")
  # =>
  @["a"]

  (peg/match ~(capture 2) "hi")
  # =>
  @["hi"]

  (peg/match ~(quote 2) "hi")
  # =>
  @["hi"]

  (peg/match ~'2 "hi")
  # =>
  @["hi"]

  (peg/match ~(capture -1) "")
  # =>
  @[""]

  (peg/match '(capture 1 :a) "a")
  # =>
  @["a"]

  (peg/match ~(sequence (capture :d+ :a)
                        (backref :a))
             "78")
  # =>
  @["78" "78"]

  (peg/match ~(capture (range "ac")) "b")
  # =>
  @["b"]

  )

(comment

  (let [text (if (< (math/random) 0.5)
               "b"
               "y")
        [cap] (peg/match ~(capture (range "ac" "xz"))
                         text)]
    (or (= cap "b")
        (= cap "y")))
  # =>
  true

  (peg/match ~(capture (set "cat")) "cat")
  # =>
  @["c"]

  (peg/match ~(<- 2) "hi")
  # =>
  @["hi"]

  (peg/match ~(<- -1) "")
  # =>
  @[""]

  (peg/match ~(<- (range "ac")) "b")
  # =>
  @["b"]

  (let [text (if (< (math/random) 0.5)
               "b"
               "y")
        [cap] (peg/match ~(<- (range "ac" "xz"))
                         text)]
    (or (= cap "b")
        (= cap "y")))
  # =>
  true

  (peg/match ~(<- (set "cat")) "cat")
  # =>
  @["c"]

  (peg/match ~(quote "a") "a")
  # =>
  @["a"]

  (peg/match ~'"a" "a")
  # =>
  @["a"]

  (peg/match ~(quote -1) "")
  # =>
  @[""]

  (peg/match ~'-1 "")
  # =>
  @[""]

  (peg/match ~(quote (range "ac")) "b")
  # =>
  @["b"]

  (peg/match ~'(range "ac") "b")
  # =>
  @["b"]

  (let [text (if (< (math/random) 0.5)
               "b"
               "y")
        [cap] (peg/match ~(quote (range "ac" "xz"))
                         text)]
    (or (= cap "b")
        (= cap "y")))
  # =>
  true

  (let [text (if (< (math/random) 0.5)
               "b"
               "y")
        [cap] (peg/match ~'(range "ac" "xz")
                         text)]
    (or (= cap "b")
        (= cap "y")))
  # =>
  true

  (peg/match ~(quote (set "cat")) "cat")
  # =>
  @["c"]

  (peg/match ~'(set "cat") "cat")
  # =>
  @["c"]

  )
````````
"choice"
````````
(import ../margaret/meg :as peg)

# `(choice patt-1 patt-2 ...)`

# Tries to match patt-1, then patt-2, and so on.

# Will succeed on the first successful match, and fails if none of the
# arguments match the text.

# `(+ patt-1 patt-2 ...)` is an alias for `(choice patt-1 patt-2 ...)`

(comment

  (peg/match ~(choice) "")
  # =>
  nil

  (peg/match ~(choice) "a")
  # =>
  nil

  (peg/match ~(choice 1)
             "a")
  # =>
  @[]

  (peg/match ~(choice (capture 1))
             "a")
  # =>
  @["a"]

  (peg/match ~(choice "a" "b")
             "a")
  # =>
  @[]

  (peg/match ~(+ "a" "b")
             "a")
  # =>
  @[]

  (peg/match ~(choice "a" "b")
             "b")
  # =>
  @[]

  (peg/match ~(choice "a" "b")
             "c")
  # =>
  nil

  )
````````
"cms"
````````
(import ../margaret/meg :as peg)

# `(cms patt fun ?tag)`

# Invokes `fun` with all of the captures of `patt` as arguments (if
# `patt` matches).

# If the result is an indexed type, then captures the elements of the
# result.  If the result is not an indexed type, then captures the
# result.

# The whole expression fails if `fun` returns false or nil.

(comment

  (peg/match ~(cms (sequence 1 (capture 1) 1)
                   ,|[$ $ $])
             "abc")
  # =>
  @["b" "b" "b"]

  (peg/match ~(cms (sequence 1 1 (capture 1))
                   ,|@[$ $ $])
             "abc")
  # =>
  @["c" "c" "c"]

  (peg/match ~(cms (capture 1)
                   ,(fn [cap]
                      (= cap "a")))
             "a")
  # =>
  @[true]

  (peg/match ~(cms (capture 1)
                   ,(fn [cap]
                      (= cap "a")))
             "b")
  # =>
  nil

  (peg/match ~(cms (capture "hello")
                   ,(fn [cap]
                      (string cap "!")))
             "hello")
  # =>
  @["hello!"]

  (peg/match ~(cms (sequence (capture "hello")
                             (some (set " ,"))
                             (capture "world"))
                   ,(fn [cap1 cap2]
                      (string cap2 ": yes, " cap1 "!")))
             "hello, world")
  # =>
  @["world: yes, hello!"]

  )

(comment

  (peg/match ~{:main :pair
               :pair (sequence (cms (capture :key)
                                    ,identity)
                               "="
                               (cms (capture :value)
                                    ,identity))
               :key (any (sequence (not "=")
                                   1))
               :value (any (sequence (not "&")
                                     1))}
             "name=tao")
  # =>
  @["name" "tao"]

  )
````````
"cmt"
````````
(import ../margaret/meg :as peg)

# `(cmt patt fun ?tag)`

# Invokes `fun` with all of the captures of `patt` as arguments (if
# `patt` matches).

# If the result is truthy, then captures the result.

# The whole expression fails if `fun` returns false or nil.

(comment

  (peg/match ~(cmt (sequence 1 (capture 1) 1)
                   ,|[$ $ $])
             "abc")
  # =>
  @[["b" "b" "b"]]

  (peg/match ~(cmt (sequence 1 1 (capture 1))
                   ,|@[$ $ $])
             "abc")
  # =>
  @[@["c" "c" "c"]]

  (peg/match ~(cmt (capture 1)
                   ,(fn [cap]
                      (= cap "a")))
             "a")
  # =>
  @[true]

  (peg/match ~(cmt (capture 1)
                   ,(fn [cap]
                      (= cap "a")))
             "b")
  # =>
  nil

  (peg/match ~(cmt (capture "hello")
                   ,(fn [cap]
                      (string cap "!")))
             "hello")
  # =>
  @["hello!"]

  (peg/match ~(cmt (sequence (capture "hello")
                             (some (set " ,"))
                             (capture "world"))
                   ,(fn [cap1 cap2]
                      (string cap2 ": yes, " cap1 "!")))
             "hello, world")
  # =>
  @["world: yes, hello!"]

  )

(comment

  (peg/match ~{:main :pair
               :pair (sequence (cmt (capture :key)
                                    ,identity)
                               "="
                               (cmt (capture :value)
                                    ,identity))
               :key (any (sequence (not "=")
                                   1))
               :value (any (sequence (not "&")
                                     1))}
             "name=tao")
  # =>
  @["name" "tao"]

  )
````````
"column"
````````
(import ../margaret/meg :as peg)

# `(column ?tag)`

# Captures the column of the current index into the text and advances no input.

(comment

  (peg/match ~(column)
             "a")
  # =>
  @[1]

  (peg/match ~(sequence "a"
                        (column))
             "ab")
  # =>
  @[2]

  (peg/match ~(sequence "a\n"
                        (column))
             "a\nb")
  # =>
  @[1]

  (peg/match ~(sequence "a\nb"
                        (column))
             "a\nb")
  # =>
  @[2]

  (peg/match ~(sequence "ab"
                        (column)
                        (capture "c"))
             "abc")
  # =>
  @[3 "c"]

  )
````````
"constant"
````````
(import ../margaret/meg :as peg)

# `(constant k ?tag)`

# Captures a constant value and advances no characters.

(comment

  (peg/match ~(constant "smile")
             "whatever")
  # =>
  @["smile"]

  (peg/match ~(constant {:fun :value})
             "whatever")
  # =>
  @[{:fun :value}]

  (peg/match ~(sequence (constant :relax)
                        (position))
             "whatever")
  # =>
  @[:relax 0]

  )
````````
"debug"
````````
(import ../margaret/meg :as peg)

# `(debug)`

# Print capture stack (sometimes partial) to stdout.

# `(??)` is an alias for `(debug)`

(comment

  (def eol (if (= :windows (os/which)) "\r\n" "\n"))

  (let [buf @""]
    (with-dyns [:out buf]
      [(peg/match ~(sequence (capture "a") (??))
                  "a")
       buf]))
  # =>
  [@["a"]
   (buffer eol
           "?? at []" eol
           "stack [1]:" eol
           "  [0]: \e[35m" `"a"` "\e[0m" eol)]

  (let [buf @""]
    (with-dyns [:out buf]
      [(peg/match ~(sequence (debug) "abc")
                  "abc")
       buf]))
  # =>
  [@[]
   (buffer eol
           "?? at [abc]" eol
           "stack [0]:" eol)]

  (let [buf @""]
    (with-dyns [:out buf]
      [(peg/match ~(sequence (??) "abc")
                  "abc")
       buf]))
  # =>
  [@[]
   (buffer eol
           "?? at [abc]" eol
           "stack [0]:" eol)]

  (let [buf @""]
    (with-dyns [:out buf]
      [(peg/match ~(sequence "abc" (??))
                  "abc")
       buf]))
  # =>
  [@[]
   (buffer eol
           "?? at []" eol
           "stack [0]:" eol)]

  (let [buf @""]
    (with-dyns [:out buf]
      [(peg/match ~(sequence "a" (??) "bc")
                  "abc")
       buf]))
  # =>
  [@[]
   (buffer eol
           "?? at [bc]" eol
           "stack [0]:" eol)]

  (let [buf @""]
    (with-dyns [:out buf]
      [(peg/match ~(sequence (capture "a") (??) "bc")
                  "abc")
       buf]))
  # =>
  [@["a"]
   (buffer eol
           "?? at [bc]" eol
           "stack [1]:" eol
           "  [0]: \e[35m" `"a"` "\e[0m" eol)]

  (let [buf @""]
    (with-dyns [:out buf]
      [(peg/match ~(sequence (capture "a")
                             (number :d)
                             (constant true)
                             (constant {})
                             (constant @[])
                             (??)
                             "bc")
                  "a1bc")
       buf]))
  # =>
  [@["a" 1 true {} @[]]
   (buffer eol
           "?? at [bc]" eol
           "stack [5]:" eol
           "  [0]: \e[35m" `"a"` "\e[0m" eol
           "  [1]: \e[32m" "1" "\e[0m" eol
           "  [2]: \e[36m" "true" "\e[0m" eol
           "  [3]: {}" eol
           "  [4]: @[]" eol)]

  )
````````
"drop"
````````
(import ../margaret/meg :as peg)

# `(drop patt)`

# Ignores (drops) all captures from `patt`.

(comment

  (peg/match ~(drop (capture 1))
             "a")
  # =>
  @[]

  (peg/match ~(sequence (drop (cmt (capture 3)
                                   ,scan-number))
                        (capture (any 1)))
             "-1.89")
  # =>
  @["89"]

  )
````````
"error"
````````
(import ../margaret/meg :as peg)

# `(error ?patt)`

# Throws a Janet error.

# The error thrown will be the last capture of `patt`, or a generic error if
# `patt` produces no captures or `patt` is not specified.

# If `patt` does not match, no error will be thrown.

(comment

  # error match failure
  (peg/match ~(error "ho")
             "")
  # =>
  nil

  )

(comment

  (try
    (peg/match ~(sequence "a"
                          "\n"
                          "b"
                          "\n"
                          "c"
                          (error))
               "a\nb\nc")
    ([e] e))
  # =>
  "match error at line 3, column 2"

  (try
    (peg/match ~(error (capture "a"))
               "a")
    ([e] e))
  # =>
  "a"

  (try
    (peg/match ~(sequence "a"
                          (error (sequence (capture "b")
                                           (capture "c"))))
               "abc")
    ([err]
      err))
  # =>
  "c"

  (try
    (peg/match ~(choice "a"
                        "b"
                        (error ""))
               "c")
    ([err]
      err))
  # =>
  "match error at line 1, column 1"

  (try
    (peg/match ~(choice "a"
                        "b"
                        (error))
               "c")
    ([err]
      :match-error))
  # =>
  :match-error

  )
````````
"group"
````````
(import ../margaret/meg :as peg)

# `(group patt ?tag)`

# Captures an array of all of the captures in `patt`

(comment

  (peg/match ~(group (sequence (capture 1)
                               (capture 1)
                               (capture 1)))
           "abc")
  # =>
  @[@["a" "b" "c"]]

  (first
    (peg/match ~(group (sequence (capture "(")
                                 (capture (any (if-not ")" 1)))
                                 (capture ")")))
               "(defn hi [] 1)"))
  # =>
  @["(" "defn hi [] 1" ")"]

  (peg/match ~(group (sequence (capture "a")
                               (group (capture "b"))))
             "ab")
  # =>
  @[@["a" @["b"]]]

  )
````````
"if-not"
````````
(import ../margaret/meg :as peg)

# `(if-not cond patt)`

# Tries to match only if `cond` does not match.

# `cond` will not produce any captures.

(comment

  (peg/match ~(if-not 2 "a")
             "a")
  # =>
  @[]

  (peg/match ~(if-not 5 (set "iknw"))
             "wink")
  # =>
  @[]

  # https://github.com/janet-lang/janet/issues/1026
  (peg/match ~(if-not (sequence (constant 7) "a") "hello")
             "hello")
  # =>
  @[]

  # https://github.com/janet-lang/janet/issues/1026
  (peg/match ~(if-not (drop (sequence (constant 7) "a")) "hello")
             "hello")
  # =>
  @[]

  )
````````
"if"
````````
(import ../margaret/meg :as peg)

# `(if cond patt)`

# Tries to match `patt` only if `cond` matches as well.

# `cond` will not produce any captures.

(comment

  (peg/match ~(if 1 "a")
             "a")
  # =>
  @[]

  (peg/match ~(if 5 (set "eilms"))
             "smile")
  # =>
  @[]

  (peg/match ~(if 5 (set "eilms"))
             "wink")
  # =>
  nil

  )
````````
"int-be"
````````
(import ../margaret/meg :as peg)

# `(int-be n ?tag)`

# Captures `n` bytes interpreted as a big endian integer.

(comment

  (peg/match '(int-be 1) "a")
  # =>
  @[(chr "a")]

  (peg/match ~(int-be 2) "ab")
  # =>
  @[24930]

  (deep=
    (peg/match ~(int-be 8) "abcdefgh")
    @[(int/s64 "7017280452245743464")])
  # =>
  true

  (peg/match ~(sequence (int-be 2 :a)
                        (backref :a))
             "ab")
  # =>
  @[24930 24930]

  (peg/match '(int-be 1) "\xFF")
  # =>
  @[-1]

  (peg/match '(int-be 2) "\x7f\xff")
  # =>
  @[0x7fff]

  )
````````
"int"
````````
(import ../margaret/meg :as peg)

# `(int n ?tag)`

# Captures `n` bytes interpreted as a little endian integer.

(comment

  (peg/match ~(int 1) "a")
  # =>
  @[97]

  (peg/match ~(int 2) "ab")
  # =>
  @[25185]

  (peg/match ~(int 8) "abcdefgh")
  # =>
  @[(int/s64 "7523094288207667809")]

  (peg/match ~(sequence (int 2 :a)
                        (backref :a))
             "ab")
  # =>
  @[25185 25185]

  (peg/match '(int 1) "\xFF")
  # =>
  @[-1]

  (peg/match '(int 2) "\xFF\x7f")
  # =>
  @[0x7fff]

  (peg/match '(int 8)
             "\xff\x7f\x00\x00\x00\x00\x00\x00")
  # =>
  @[(int/s64 0x7fff)]

  (peg/match '(int 7)
             "\xff\x7f\x00\x00\x00\x00\x00")
  # =>
  @[(int/s64 0x7fff)]

  (peg/match '(sequence (int 2) -1)
             "123")
  # =>
  nil

  )
````````
"lenprefix"
````````
(import ../margaret/meg :as peg)

# `(lenprefix n patt)`

# Matches `n` repetitions of `patt`, where `n` is supplied from other parsed
# input and is not constant.

# `n` is obtained from the capture stack.

(comment

  (peg/match ~(lenprefix (number :d) 1)
             "2xy")
  # =>
  @[]

  (peg/match ~(capture (lenprefix (number :d) 1))
             "2xy")
  # =>
  @["2xy"]

  (peg/match ~(sequence (number :d nil :tag)
                        (capture (lenprefix (backref :tag)
                                            1)))
             "3abc")
  # =>
  @[3 "abc"]

  (peg/match ~(replace (sequence (number :d 10 :tag)
                                 (capture (lenprefix (backref :tag)
                                                     1)))
                       ,(fn [num cap]
                          cap))
             "3abc")
  # =>
  @["abc"]

  (peg/match
    ~(repeat 2
       (replace (lenprefix (number :d+) (capture 1))
                ,|(string ;$&)))
    "2aa1b")
  # =>
  @["aa" "b"]

  (peg/match
    ~(repeat 2
       (accumulate (lenprefix (number :d+) (capture 1))))
    "2aa1b")
  # =>
  @["aa" "b"]

  (peg/match ~(lenprefix
                (replace (sequence (capture (any (if-not ":" 1)))
                                   ":")
                         ,scan-number)
                1)
             "8:abcdefgh")
  # =>
  @[]

  )

(comment

  (def lenprefix-peg
    ~(sequence
       (lenprefix
         (replace (sequence (capture (any (if-not ":" 1)))
                            ":")
                  ,scan-number)
         1)
       -1))

  (peg/match lenprefix-peg "5:abcde")
  # =>
  @[]

  (peg/match lenprefix-peg "5:abcdef")
  # =>
  nil

  (peg/match lenprefix-peg "5:abcd")
  # =>
  nil

  )
````````
"line"
````````
(import ../margaret/meg :as peg)

# `(line ?tag)`

# Captures the line of the current index into the text and advances no input.

(comment

  (peg/match ~(line)
             "a")
  # =>
  @[1]

  (peg/match ~(sequence "a\n"
                        (line))
             "a\nb")
  # =>
  @[2]

  (peg/match ~(sequence "a"
                        (line)
                        (capture "b"))
             "ab")
  # =>
  @[1 "b"]

  )
````````
"look"
````````
(import ../margaret/meg :as peg)

# `(look ?offset patt)`

# Matches only if `patt` matches at a fixed offset.  `offset` should
# be an integer and defaults to 0.

# The peg will not advance any characters.

# `(> offset patt)` is an alias for `(look offset patt)`

(comment

  (peg/match ~(look 3 "cat")
             "my cat")
  # =>
  @[]

  (peg/match ~(look 3 (capture "cat"))
             "my cat")
  # =>
  @["cat"]

  (peg/match ~(look -4 (capture "cat"))
             "my cat")
  # =>
  nil

  (peg/match ~(sequence (look 3 "cat")
                        "my")
             "my cat")
  # =>
  @[]

  (peg/match ~(sequence "my"
                        (look -2 "my")
                        " "
                        (capture "cat"))
             "my cat")
  # =>
  @["cat"]

  (peg/match ~(capture (look 3 "cat"))
             "my cat")
  # =>
  @[""]

 (peg/match '(sequence (look 2) (capture 1)) "a")
  # =>
  nil

  (peg/match '(sequence (look 2) (capture 1)) "ab")
  # =>
  @["a"]

  (peg/match ~(> 3 "cat")
             "my cat")
  # =>
  @[]

  (peg/match ~(sequence (> 3 "cat")
                        "my")
             "my cat")
  # =>
  @[]

  )
````````
"not"
````````
(import ../margaret/meg :as peg)

# `(not patt)`

# Matches only if `patt` does not match.

# Will not produce captures or advance any characters.

# `(! patt)` is an alias for `(not patt)`

(comment

  (peg/match ~(not "cat") "dog")
  # =>
  @[]

  (peg/match ~(sequence (not "cat")
                        (set "dgo"))
             "dog")
  # =>
  @[]

  (peg/match ~(! "cat") "dog")
  # =>
  @[]

  # https://github.com/janet-lang/janet/issues/1026
  (peg/match ~(not (sequence (constant 7) "a"))
             "hello")
  # =>
  @[]

  # https://github.com/janet-lang/janet/issues/1026
  (peg/match ~(if (not (sequence (constant 7) "a")) "hello")
             "hello")
  # =>
  @[]

  )
````````
"nth"
````````
(import ../margaret/meg :as peg)

# `(nth index patt ?tag)`

# Capture one of the captures in `patt` at `index`.  If no such
# capture exists, then the match fails.

(comment

  (peg/match ~(nth 2 (sequence (capture 1)
                               (capture 1)
                               (capture 1)))
             "xyz")
  # =>
  @["z"]

  (peg/match ~{:main (some (nth 1 (* :prefix ":" :word)))
               :prefix (number :d+ nil :n)
               :word (capture (lenprefix (backref :n) :w))}
             "3:fox8:elephant")
  # =>
  @["fox" "elephant"]

  )
````````
"number"
````````
(import ../margaret/meg :as peg)

# `(number patt ?base ?tag)`

# Capture a number if `patt` matches and the matched text scans as a number.

# If specified, `base` should be a number between 2 and 36 inclusive or nil.
# If `base` is not nil, interpreting the string will be done according to
# radix `base`.  If `base` is nil,  interpreting the string will be done
# via `scan-number` as-is.

# Note that if the capture is tagged, the captured content available via
# the tag (e.g. using `backref`) is a number and not a string.

(comment

  (peg/match '(number :d+) "18")
  # =>
  @[18]

  (peg/match ~(number :w+) "0xab")
  # =>
  @[171]

  (peg/match ~(number :w+ 8) "10")
  # =>
  @[8]

  (peg/match '(number (sequence (some (choice :d "_"))))
             "60_000 ganges rivers")
  # =>
  @[60000]

  (peg/match ~(number :d+ nil :my-tag) "18")
  # =>
  @[18]

  (peg/match '(number :w+ nil :your-tag) "0xab")
  # =>
  @[171]

  (peg/match ~(sequence (number :d+ nil :a)
                        (backref :a))
             "28")
  # =>
  @[28 28]

  )

(comment

  (let [chunked
        (string "4\r\n"
                "Wiki\r\n"
                "6\r\n"
                "pedia \r\n"
                "E\r\n"
                "in \r\n"
                "\r\n"
                "chunks.\r\n"
                "0\r\n"
                "\r\n")]
    (peg/match ~(some (sequence
                        (number :h+ 16 :length)
                        "\r\n"
                        (capture
                          (lenprefix (backref :length)
                                     1))
                        "\r\n"))
               chunked))
  # =>
  @[4 "Wiki" 6 "pedia " 14 "in \r\n\r\nchunks." 0 ""]

  )
````````
"only-tags"
````````
(import ../margaret/meg :as peg)

# `(only-tags patt)`

# Ignores all captures from `patt`, while making tagged captures
# within `patt` available for future back-referencing.

(comment

  (peg/match ~(sequence (only-tags (sequence (capture 1 :a)
                                             (capture 2 :b)))
                        (backref :a))
             "xyz")
  # =>
  @["x"]

  (peg/match
    ~{:main (some (sequence (only-tags (sequence :prefix ":" :word))
                            (backref :target)))
      :prefix (number :d+ nil :n)
      :word (capture (lenprefix (backref :n) :w)
                     :target)}
    "3:ant3:bee6:flower")
  # =>
  @["ant" "bee" "flower"]

  )
````````
"position"
````````
(import ../margaret/meg :as peg)

# `(position ?tag)`

# Captures the current index into the text and advances no input.

# `($ ?tag)` is an alias for `(position ?tag)`

(comment

  (peg/match ~(position) "a")
  # =>
  @[0]

  (peg/match ~(sequence "a"
                        (position))
             "ab")
  # =>
  @[1]

  (peg/match ~(sequence (capture "w")
                        (position :p)
                        (backref :p))
             "whatever")
  # =>
  @["w" 1 1]

  (peg/match ~($) "a")
  # =>
  @[0]

  (peg/match ~(sequence "a"
                        ($))
             "ab")
  # =>
  @[1]

  )

(comment

  (def rand-int
    (-> (os/cryptorand 3)
        math/rng
        (math/rng-int 90)
        inc))

  (def a-buf
    (buffer/new-filled rand-int 66))

  rand-int
  # =>
  (- (- ;(peg/match ~(sequence (position)
                               (some 1)
                               -1
                               (position))
                    a-buf)))

  )
````````
"range"
````````
(import ../margaret/meg :as peg)

# `(range r1 ?r2 .. ?rn)`

# Matches characters in a range and advances 1 character.

(comment

  (peg/match ~(range "aa")
             "a")
  # =>
  @[]

  (peg/match ~(capture (range "az"))
             "c")
  # =>
  @["c"]

  (peg/match ~(capture (range "az" "AZ"))
             "J")
  # =>
  @["J"]

  (peg/match ~(capture (range "09"))
             "123")
  # =>
  @["1"]

  )

(comment

  (let [text (if (< (math/random) 0.5)
               "b"
               "y")]
    (peg/match ~(range "ac" "xz")
               text))
  # =>
  @[]

  )
````````
"repeat"
````````
(import ../margaret/meg :as peg)

# `(repeat n patt)`

# Matches exactly n repetitions of x

# `(n patt)` is an alias for `(repeat n patt)`

(comment

  (peg/match ~(repeat 3 "m")
             "mmm")
  # =>
  @[]

  (peg/match ~(repeat 2 "m")
             "m")
  # =>
  nil

  (peg/match ~(3 "m")
             "mmm")
  # =>
  @[]

  (peg/match ~(2 "m")
             "m")
  # =>
  nil

  )
````````
"replace"
````````
(import ../margaret/meg :as peg)

# `(replace patt subst ?tag)`

# Replaces the captures produced by `patt` by applying `subst` to them.

# If `subst` is a table or struct, will push `(get subst last-capture)` to
# the capture stack after removing the old captures.

# If `subst` is a function, will call `subst` with the captures of `patt`
# as arguments and push the result to the capture stack.

# Otherwise, will push `subst` literally to the capture stack.

# `(/ patt subst ?tag)` is an alias for `(replace patt subst ?tag)`

(comment

  (peg/match ~(replace (capture "cat")
                       {"cat" "tiger"})
             "cat")
  # =>
  @["tiger"]

  (peg/match ~(/ (capture "cat")
                 {"cat" "tiger"})
             "cat")
  # =>
  @["tiger"]

  (peg/match ~(replace (sequence (capture "ant")
                                 (capture "bee"))
                       {"ant" "fox"
                        "bee" "elephant"})
             "antbee")
  # =>
  @["elephant"]

  (peg/match ~(replace (capture "cat")
                       ,(fn [original]
                          (string original "alog")))
             "cat")
  # =>
  @["catalog"]

  (peg/match ~(replace (sequence (capture "ca")
                                 (capture "t"))
                       ,(fn [one two]
                          (string one two "alog")))
             "cat")
  # =>
  @["catalog"]

  )

(comment

  (peg/match ~(replace (capture "cat")
                       "dog")
             "cat")
  # =>
  @["dog"]

  (peg/match ~(/ (capture "cat")
                 ,(fn [original]
                    (string original "alog")))
             "cat")
  # =>
  @["catalog"]

  (peg/match ~(/ (capture "cat")
                 "dog")
             "cat")
  # =>
  @["dog"]

  (peg/match ~(replace (capture "cat")
                       :hi)
             "cat")
  # =>
  @[:hi]

  (peg/match ~(capture (replace (capture "cat")
                                :hi))
             "cat")
  # =>
  @[:hi "cat"]

  )
````````
"sequence"
````````
(import ../margaret/meg :as peg)

# `(sequence patt-1 patt-2 ...)`

# Tries to match patt-1, patt-2, and so on in sequence.

# If any of these arguments fail to match the text, the whole pattern fails.

# `(* patt-1 patt-2 ...)` is an alias for `(sequence patt-1 patt-2 ...)`

(comment

  (peg/match ~(sequence) "a")
  # =>
  @[]

  (peg/match ~(sequence "a" "b" "c")
             "abc")
  # =>
  @[]

  (peg/match ~(* "a" "b" "c")
             "abc")
  # =>
  @[]

  (peg/match ~(sequence "a" "b" "c")
             "abcd")
  # =>
  @[]

  (peg/match ~(sequence "a" "b" "c")
             "abx")
  # =>
  nil

  (peg/match ~(sequence (capture 1 :a)
                        (capture 1)
                        (capture 1 :c))
             "abc")
  # =>
  @["a" "b" "c"]

  )

(comment

  (peg/match
    ~(sequence (capture "a"))
    "a")
  # =>
  @["a"]

  (peg/match
    ~(capture "a")
    "a")
  # =>
  (peg/match
    ~(sequence (capture "a"))
    "a")

  (peg/match
    ~(sequence (capture (choice "a" "b")))
    "a")
  # =>
  @["a"]

  (peg/match
    ~(capture (+ "GET" "POST" "PATCH" "DELETE"))
    "PATCH")
  # =>
  @["PATCH"]

  # thanks pepe
  (peg/match
    ~(capture (choice "GET" "POST" "PATCH" "DELETE"))
    "PATCH")
  # =>
  (peg/match
    ~(sequence (capture (choice "GET" "POST" "PATCH" "DELETE")))
    "PATCH")

  )
````````
"set"
````````
(import ../margaret/meg :as peg)

# `(set chars)`

# Match any character in the argument string. Advances 1 character.

(comment

  (peg/match ~(set "act")
             "cat")
  # =>
  @[]

  (peg/match ~(set "act!")
             "cat!")
  # =>
  @[]

  (peg/match ~(set "bo")
             "bob")
  # =>
  @[]

  (peg/match ~(capture (set "act"))
             "cat")
  # =>
  @["c"]

  )
````````
"some"
````````
(import ../margaret/meg :as peg)

# `(some patt)`

# Matches 1 or more repetitions of `patt`

(comment

  # some with empty string
  (peg/match ~(some "a")
             "")
  # =>
  nil

  # some
  (peg/match ~(some "a")
             "aa")
  # =>
  @[]

  # some with capture
  (peg/match ~(capture (some "a"))
             "aa")
  # =>
  @["aa"]

  )
````````
"split"
````````
(import ../margaret/meg :as peg)

# `(split separator-patt patt)`

# Split the remaining input by `separator-patt`, and execute `patt` on
# each substring.

# `patt` will execute with its input constrained to the next instance of
# `separator-patt`, as if narrowed by `(sub (to separator-patt) ...)`.

# `split` will continue to match separators and patterns until it reaches
# the end of the input; if you don't want to match to the end of the
# input you should first narrow it with `(sub ... (split ...))`.

(comment

  (peg/match ~(split "," (capture 1))
             "a,b,c")
  # =>
  @["a" "b" "c"]

  # drops captures from separator pattern
  (peg/match ~(split (capture ",") (capture 1))
             "a,b,c")
  # =>
  @["a" "b" "c"]

  # can match empty subpatterns
  (peg/match ~(split "," (capture :w*))
             ",a,,bar,,,c,,")
  # =>
  @["" "a" "" "bar" "" "" "c" "" ""]

  # subpattern is limited to only text before the separator
  (peg/match ~(split "," (capture (to -1)))
             "a,,bar,c")
  # =>
  @["a" "" "bar" "c"]

  # fails if any subpattern fails
  (peg/match ~(split "," (capture "a"))
             "a,a,b")
  # =>
  nil

  # separator does not have to match anything
  (peg/match ~(split "x" (capture (to -1)))
             "a,a,b")
  # =>
  @["a,a,b"]

  # always consumes entire input
  (peg/match ~(split 1 (capture ""))
             "abc")
  # =>
  @["" "" "" ""]

  # separator can be an arbitrary PEG
  (peg/match ~(split :s+ (capture (to -1)))
             "a   b      c")
  # =>
  @["a" "b" "c"]

  # does not advance past the end of the input
  (peg/match ~(sequence (split "," (capture :w+)) 0)
             "a,b,c")
  # =>
  @["a" "b" "c"]

  # issue #1539 at janet repository
  (peg/match ~(split "" (capture (to -1)))
             "hello there friends")
  # =>
  nil

  )
````````
"sub"
````````
(import ../margaret/meg :as peg)

# `(sub window-patt patt)`

# Match `window-patt` and if it succeeds, match `patt` against the
# bytes that `window-patt` matched.

# `patt` cannot match more than `window-patt`; it will see
# end-of-input at the end of the substring matched by `window-patt`.

# If `patt` also succeeds, `sub` will advance to the end of what
# `window-patt` matched.

# If any of the `col`, `line`, `position`, or `error` specials appear
# in `patt`, they still yield values relative to the whole input.

(comment

  # matches the same input twice
  (peg/match ~(sub "abcd" "abc")
             "abcdef")
  # =>
  @[]

  # second pattern cannot match more than the first pattern
  (peg/match ~(sub "abcd" "abcde")
             "abcdef")
  # =>
  nil

  # fails if first pattern fails
  (peg/match ~(sub "x" "abc")
             "abcdef")
  # =>
  nil

  # fails if second pattern fails
  (peg/match ~(sub "abc" "x")
             "abcdef")
  # =>
  nil

  # keeps captures from both patterns
  (peg/match ~(sub (capture "abcd") (capture "abc"))
             "abcdef")
  # =>
  @["abcd" "abc"]

  # second pattern can reference captures from first
  (peg/match ~(sequence (constant 5 :tag)
                        (sub (capture "abc" :tag)
                             (backref :tag)))
             "abcdef")
  # =>
  @[5 "abc" "abc"]

  # second pattern can't see past what the first pattern matches
  (peg/match ~(sub "abc" (sequence "abc" -1))
             "abcdef")
  # =>
  @[]

  # positions inside second match are still relative to the entire input
  (peg/match ~(sequence "one\ntw"
                        (sub "o" (sequence (position) (line) (column))))
             "one\ntwo\nthree\n")
  # =>
  @[6 2 3]

  # advances to the end of the first pattern's match
  (peg/match ~(sequence (sub "abc" "ab")
                        "d")
             "abcdef")
  # =>
  @[]

 (peg/match ~(sequence (sub (capture "abcd" :a)
                            (capture "abc"))
                       (capture (backmatch)))
            "abcdabcd")
  # =>
  @["abcd" "abc" "abc"]

  (peg/match ~(sequence (sub (capture "abcd" :a)
                             (capture "abc"))
                        (capture (backmatch :a)))
             "abcdabcd")
  # =>
  @["abcd" "abc" "abcd"]

  (peg/match ~(sequence (capture "abcd" :a)
                        (sub (capture "abc" :a)
                             (capture (backmatch :a)))
                        (capture (backmatch :a)))
             "abcdabcabcd")
  # =>
  @["abcd" "abc" "abc" "abc"]

  (peg/match ~(sequence (capture "abcd" :a)
                        (sub (capture "abc")
                             (capture (backmatch)))
                        (capture (backmatch :a)))
             "abcdabcabcd")
  # =>
  @["abcd" "abc" "abc" "abcd"]

  (peg/match ~(sub (capture "abcd")
                   (look 3 (capture "d")))
             "abcdcba")
  # =>
  @["abcd" "d"]

  (peg/match ~(sub (capture "abcd")
                   (capture (to "c")))
             "abcdef")
  # =>
  @["abcd" "ab"]

  (peg/match ~(sub (capture (to "d"))
                   (capture "abc"))
             "abcdef")
  # =>
  @["abc" "abc"]

  (peg/match ~(sub (capture (to "d"))
                   (capture (to "c")))
             "abcdef")
  # =>
  @["abc" "ab"]

  (peg/match ~(sequence (sub (capture (to "d"))
                             (capture (to "c")))
                        (capture (to "f")))
             "abcdef")
  # =>
  @["abc" "ab" "de"]

  (peg/match ~(sub (capture "abcd")
                   (capture (thru "c")))
             "abcdef")
  # =>
  @["abcd" "abc"]

  (peg/match ~(sub (capture (thru "d"))
                   (capture "abc"))
             "abcdef")
  # =>
  @["abcd" "abc"]

  (peg/match ~(sub (capture (thru "d"))
                   (capture (thru "c")))
             "abcdef")
  # =>
  @["abcd" "abc"]

  (peg/match ~(sequence (sub (capture (thru "d"))
                             (capture (thru "c")))
                        (capture (thru "f")))
             "abcdef")
  # =>
  @["abcd" "abc" "ef"]

  (peg/match ~(sequence (sub (capture 3)
                             (capture 2))
                        (capture 3))
             "abcdef")
  # =>
  @["abc" "ab" "def"]

  (peg/match ~(sub (capture -7)
                   (capture -1))
             "abcdef")
  # =>
  @["" ""]

  (peg/match ~(sequence (sub (capture -7)
                             (capture -1))
                        (capture 1))
             "abcdef")
  # =>
  @["" "" "a"]

  (peg/match ~(sequence (sub (capture (repeat 3 (range "ac")))
                             (capture (repeat 2 (range "ab"))))
                        (capture (repeat 3 (range "df"))))
             "abcdef")
  # =>
  @["abc" "ab" "def"]

  (peg/match ~(sequence (sub (capture (repeat 3 (set "abc")))
                             (capture (repeat 2 (set "ab"))))
                        (capture (repeat 3 (set "def"))))
             "abcdef")
  # =>
  @["abc" "ab" "def"]

  (peg/match ~(sequence (sub (capture "abcd")
                             (int 1))
                        (int 1))
             "abcdef")
  # =>
  @["abcd" 97 101]

  (peg/match ~(sequence (sub (capture "ab")
                             (int 3)))
             "abcdef")
  # =>
  nil

  (peg/match ~(sub (capture "abcd")
                   (sub (capture "abc")
                        (capture "ab")))
             "abcdef")
  # =>
  @["abcd" "abc" "ab"]

  )

(comment

  (try
    (peg/match ~(sequence "a"
                          (sub "bcd" (error "bc")))
               "abcdef")
    ([e] e))
  # =>
  "match error at line 1, column 2"


  )
````````
"thru"
````````
(import ../margaret/meg :as peg)

# `(thru patt)`

# Match up through `patt` (thus including it).

# If the end of the input is reached and `patt` is not matched, the entire
# pattern does not match.

(comment

  (peg/match ~(thru "\n")
             "this is a nice line\n")
  # =>
  @[]

  (peg/match ~(sequence (thru "\n")
                        "\n")
             "this is a nice line\n")
  # =>
  nil

  (peg/match ~(sequence "(" (thru ")"))
             "(12345)")
  # =>
  @[]

  (peg/match ~(sequence "(" (thru ")"))
             " (12345)")
  # =>
  nil

  (peg/match ~(sequence "(" (thru ")"))
             "(12345")
  # =>
  nil

  )

(comment

  # issue #640 in janet
  (peg/match '(thru -1) "aaaa")
  # =>
  @[]

  (peg/match ''(thru -1) "aaaa")
  # =>
  @["aaaa"]

  (peg/match '(thru "b") "aaaa")
  # =>
  nil

  # https://github.com/janet-lang/janet/issues/971
  (peg/match
    '{:dd (sequence :d :d)
      :sep (set "/-")
      :date (sequence :dd :sep :dd)
      :wsep (some (set " \t"))
      :entry (group (sequence (capture :date) :wsep (capture :date)))
      :main (some (thru :entry))}
    "1800-10-818-9-818 16/12\n17/12 19/12\n20/12 11/01")
  # =>
  @[@["17/12" "19/12"]
    @["20/12" "11/01"]]

  )
````````
"til"
````````
(import ../margaret/meg :as peg)

# `(til sep patt)`

# Match `patt` up to (but not including) the first character of what
# `(to sep)` matches.

# If `(to sep)` does not match, the entire pattern does not match.

# If match succeeds, advance one character beyond the last character
# matched by `(to sep)`.

# Any captures made by `(to sep)` are dropped.

# `(til set patt)` might be seen as short for:

# `(sequence (sub (drop (to sep)) patt) (drop sep))`

(comment

  (peg/match ~(sequence (til "bcde" (capture (to -1)))
                        (capture (to -1)))
             "abcdef")
  # =>
  @["a" "f"]

  # basic matching
  (peg/match ~(til "d" "abc")
             "abcdef")
  # =>
  @[]

  # second pattern can't see past the first occurrence of first pattern
  (peg/match ~(til "d" (sequence "abc" -1))
             "abcdef")
  # =>
  @[]

  # fails if first pattern fails
  (peg/match ~(til "x" "abc")
             "abcdef")
  # =>
  nil

  # fails if second pattern fails
  (peg/match ~(til "abc" "x")
             "abcdef")
  # =>
  nil

  # discards captures from initial pattern
  (peg/match ~(til (capture "d") (capture "abc"))
             "abcdef")
  # =>
  @["abc"]

  # positions inside second match are still relative to the entire input
  (peg/match ~(sequence "one\ntw"
                        (til 0 (sequence (position) (line) (column))))
             "one\ntwo\nthree\n")
  # =>
  @[6 2 3]

  # advances to the end of the first pattern's first occurrence
  (peg/match ~(sequence (til "d" "ab") "e")
             "abcdef")
  # =>
  @[]

  )
````````
"to"
````````
(import ../margaret/meg :as peg)

# `(to patt)`

# Match up to `patt` (but not including it).

# If the end of the input is reached and `patt` is not matched, the entire
# pattern does not match.

(comment

  (peg/match ~(to "\n")
             "this is a nice line\n")
  # =>
  @[]

  (peg/match ~(sequence (to "\n")
                        "\n")
             "this is a nice line\n")
  # =>
  @[]

  (peg/match ~(capture (to -1)) "foo")
  # =>
  @["foo"]

  )

(comment
  
  # issue #640 in janet
  (peg/match '(to -1) "aaaa")
  # =>
  @[]

  (peg/match ''(to -1) "aaaa")
  # =>
  @["aaaa"]

  (peg/match '(to "b") "aaaa")
  # =>
  nil

  )
````````
"uint-be"
````````
(import ../margaret/meg :as peg)

# `(uint-be n ?tag)`

# Captures `n` bytes interpreted as a big endian unsigned integer.

(comment

  (peg/match ~(uint-be 1) "a")
  # =>
  @[97]

  (peg/match '(uint-be 1) "\xFF")
  # =>
  @[255]

  (peg/match '(uint-be 2)
             "\x7f\xff")
  # =>
  @[0x7fff]

  (peg/match ~(uint-be 8) "abcdefgh")
  # =>
  @[(int/u64 "7017280452245743464")]

  (peg/match ~(sequence (uint-be 2 :a)
                        (backref :a))
             "ab")
  # =>
  @[24930 24930]

  )
````````
"uint"
````````
(import ../margaret/meg :as peg)

# `(uint n ?tag)`

# Captures `n` bytes interpreted as a little endian unsigned integer.

(comment

  (peg/match ~(uint 1) "a")
  # =>
  @[97]

  (peg/match '(uint 1) "\xFF")
  # =>
  @[255]

  (peg/match '(uint 2)
             "\xff\x7f")
  # =>
  @[0x7fff]

  (peg/match '(uint 8)
             "\xff\x7f\x00\x00\x00\x00\x00\x00")
  # =>
  @[(int/u64 0x7fff)]

  (peg/match '(uint 7)
             "\xff\x7f\x00\x00\x00\x00\x00")
  # =>
  @[(int/u64 0x7fff)]

  (peg/match ~(uint 8) "abcdefgh")
  # =>
  @[(int/u64 "7523094288207667809")]

  (peg/match ~(sequence (uint 2 :a)
                        (backref :a))
             "ab")
  # =>
  @[25185 25185]

  )
````````
"unref"
````````
(import ../margaret/meg :as peg)

# `(unref rule ?tag)`

# The `unref` combinator lets a user "scope" tagged captures.

# After the rule has matched, all captures with `tag` can no longer be
# referred to by their tag. However, such captures from outside the
# rule are kept as is.

# If no tag is given, all tagged captures from rule are
# unreferenced.

# Note that this doesn't `drop` the captures, merely removes their
# association with the tag. This means subsequent calls to `backref`
# and `backmatch` will no longer "see" these tagged captures.

(comment

  # try removing the unref to see what happens
  (peg/match ~{:main (sequence :thing -1)
               :thing (choice (unref (sequence :open :thing :close))
                              (capture (any (if-not "[" 1))))
               :open (capture (sequence "[" (some "_") "]")
                              :delim)
               :close (capture (backmatch :delim))}
             "[__][_]a[_][__]")
  # =>
  @["[__]" "[_]" "a" "[_]" "[__]"]

  )

(comment

  (def grammar
    ~{:main (sequence :tagged -1)
      :tagged (unref (replace (sequence :open-tag :value :close-tag)
                              ,struct))
      :open-tag (sequence (constant :tag)
                          "<"
                          (capture :w+ :tag-name)
                          ">")
      :value (sequence (constant :value)
                       (group (any (choice :tagged :untagged))))
      :close-tag (sequence "</"
                           (backmatch :tag-name)
                           ">")
      :untagged (capture (any (if-not "<" 1)))})

  (peg/match grammar "<p>Hello</p>")
  # =>
  @[{:tag "p"
     :value @["Hello"]}]

  (peg/match grammar "<p><p>Hello</p></p>")
  # =>
  @[{:tag "p"
     :value @[{:tag "p"
               :value @["Hello"]}]}]

  (peg/match grammar "<p><em>Hello</em></p>")
  # =>
  @[{:tag "p"
     :value @[{:tag "em"
               :value @["Hello"]}]}]

  )
````````
  })

(comment import ./examples :prefix "")
(comment import ./data :prefix "")


(def ex/examples-table
  @{"+" "choice"
    "*" "sequence"
    "opt" "between"
    "?" "between"
    "??" "debug"
    "!" "not"
    ">" "look"
    "<-" "capture"
    "quote" "capture"
    "'" "capture"
    "/" "replace"
    "$" "position"
    "%" "accumulate"
    "->" "backref"})

(defn ex/get-special
  [thing]
  (if-let [alias (get ex/examples-table thing)]
    alias
    (let [the-type
          (type (try (parse thing) ([e] nil)))]
      (cond
        (= :boolean the-type)
        "0.boolean"
        #
        (or (= :struct the-type)
            (= :table the-type))
        "0.dictionary"
        #
        (try (int? (scan-number thing)) ([e] nil))
        "0.integer"
        #
        (def sp (get data/names thing))
        thing
        #
        nil))))

(comment

  (ex/get-special nil)
  # =>
  nil

  (ex/get-special "1")
  # =>
  "0.integer"

  (ex/get-special "+")
  # =>
  "choice"

  (ex/get-special "->")
  # =>
  "backref"

  (ex/get-special "{:main 1}")
  # =>
  "0.dictionary"

  (ex/get-special "1.2")
  # =>
  nil

  )

# XXX: better to generate or else will get out of sync
(def ex/summary
  ``
  Primitive Patterns
    Integer (..., -1, 0, 1, ...)
    range                  =  (range r1 ?r2 ... ?rn)
    set                    =  (set chars)
    String ("...")
    Buffer (@"...")
    Boolean (true, false)

  Combining Patterns
    any                    =  (any patt)
    at-least               =  (at-least n patt)
    at-most                =  (at-most n patt)
    backmatch              =  (backmatch ?tag)
    between (opt, ?)       =  (between min max patt)
    choice (+)             =  (choice patt-1 patt-2 ...)
    if                     =  (if cond patt)
    if-not                 =  (if-not cond patt)
    look (>)               =  (look offset ?patt)
    not (!)                =  (not patt)
    repeat (0, 1, 2, ...)  =  (repeat n patt)
    sequence (*)           =  (sequence patt-1 patt-2 ...)
    some                   =  (some patt)
    split                  =  (split sep patt)
    sub                    =  (sub window-patt patt)
    thru                   =  (thru patt)
    til                    =  (til sep patt)
    to                     =  (to patt)

  Captures
    accumulate (%)         =  (accumulate pat ?tag)
    argument               =  (argument n ?tag)
    backref (->)           =  (backref prev-tag ?tag)
    capture (<-, quote)    =  (capture patt ?tag)
    cmt                    =  (cmt patt fun ?tag)
    cms                    =  (cms patt fun ?tag)
    column                 =  (column ?tag)
    constant               =  (constant k ?tag)
    drop                   =  (drop patt)
    error                  =  (error ?patt)
    group                  =  (group patt ?tag)
    int                    =  (int n ?tag)
    int-be                 =  (int-be n ?tag)
    lenprefix              =  (lenprefix n patt)
    line                   =  (line ?tag)
    nth                    =  (nth index patt ?tag)
    number                 =  (number patt ?base ?tag)
    only-tags              =  (only-tags patt)
    position ($)           =  (position ?tag)
    replace (/)            =  (replace patt subst ?tag)
    uint                   =  (uint n ?tag)
    uint-be                =  (uint-be n ?tag)
    unref                  =  (unref rule ?tag)

  Other Patterns
    debug (??)             =  (debug)

  Built-ins
    :a                     =  (range "AZ" "az")
    :d                     =  (range "09")
    :h                     =  (range "09" "AF" "af")
    :s                     =  (set " \0\f\n\r\t\v")
    :w                     =  (range "09" "AZ" "az")
    :A                     =  (if-not :a 1)
    :D                     =  (if-not :d 1)
    :H                     =  (if-not :h 1)
    :S                     =  (if-not :s 1)
    :W                     =  (if-not :w 1)
    :a+                    =  (some :a)
    :d+                    =  (some :d)
    :h+                    =  (some :h)
    :s+                    =  (some :s)
    :w+                    =  (some :w)
    :A+                    =  (some :A)
    :D+                    =  (some :D)
    :H+                    =  (some :H)
    :S+                    =  (some :S)
    :W+                    =  (some :W)
    :a*                    =  (any :a)
    :d*                    =  (any :d)
    :h*                    =  (any :h)
    :s*                    =  (any :s)
    :w*                    =  (any :w)
    :A*                    =  (any :A)
    :D*                    =  (any :D)
    :H*                    =  (any :H)
    :S*                    =  (any :S)
    :W*                    =  (any :W)

  Aliases
    (! patt)               =  (not patt)
    ($ ?tag)               =  (position ?tag)
    (% patt ?tag)          =  (accumulate patt ?tag)
    (* patt-1 ... patt-n)  =  (sequence patt-1 ... patt-n)
    (+ patt-1 ... patt-n)  =  (choice patt-1 ... patt-n)
    (-> prev-tag ?tag)     =  (backref prev-tag ?tag)
    (/ patt subst ?tag)    =  (replace patt subst ?tag)
    (<- patt ?tag)         =  (capture patt ?tag)
    (> offset ?patt)       =  (look offset ?patt)
    (? patt)               =  (between 0 1 patt)
    (1 patt)               =  (repeat 1 patt)
    (2 patt)               =  (repeat 2 patt)
    (3 patt)               =  (repeat 3 patt)
    ...
    (opt patt)             =  (between 0 1 patt)
    (quote patt ?tag)      =  (capture patt ?tag)
    'patt                  =  (capture patt)
    (??)                   =  (debug)
  ``)

(defn ex/get-content
  [special]
  (get data/names special))


(comment import ./random :prefix "")
(defn rnd/choose
  [things]
  (let [idx (math/rng-int (dyn :pdoc-rng
                               (math/rng (os/cryptorand 8)))
                          (length things))]
    (get things idx)))

(comment

  (do
    (def things
      [:a :b :c :x :y :z])

    (setdyn :pdoc-rng
            (math/rng (os/cryptorand 8)))

    (var result true)

    (for i 0 100
      (unless (index-of (rnd/choose things) things)
        (set result false)))

    result)
  # =>
  true

  )


(comment import ./show :prefix "")
(comment import ./doc :prefix "")
(comment import ./termsize :prefix "")
# based on code by bakpakin in spork's rawterm.c

(defn t/via-winapi
  []
  #
  (def coord (ffi/struct :s16 :s16))
  (def small-rect (ffi/struct :s16 :s16 :s16 :s16))
  (def csbi (ffi/struct coord coord :u16 small-rect coord))
  #
  (def i (ffi/native nil))
  #
  (def gsh (ffi/lookup i "GetStdHandle"))
  (def gsh-sig (ffi/signature :default :ptr :u32))
  #
  (def gsh-res
    # ((DWORD)-11) - signed cast to unsigned...
    (ffi/call gsh gsh-sig (- (math/abs (* 2 math/int32-min)) 11)))
  # XXX: INVALID_HANDLE_VALUE -1?
  (unless (= -1 gsh-res)
    (def gcsbi (ffi/lookup i "GetConsoleScreenBufferInfo"))
    (def gcsbi-sig (ffi/signature :default :bool :ptr :ptr))
    #
    (def buf (buffer/new-filled (ffi/size csbi) 0))
    #
    (def gcsbi-res
      (ffi/call gcsbi gcsbi-sig gsh-res buf))
    (when gcsbi-res
      (def [_ _ _ [left top right bottom] _]
        (ffi/read csbi buf))
      # =>
      #[[120 9001] [0 59] 7 [0 14 88 59] [120 49]]
      (def rows (- bottom top))
      (def cols (- right left))
      #
      [rows cols])))

(defn t/via-ioctl
  [ioctl-const]
  # ioctl_tty(2) - TIOCGWINSZ
  (def winsize (ffi/struct :ushort :ushort :ushort :ushort))
  #
  (def i (ffi/native nil))
  #
  (def ioctl (ffi/lookup i "ioctl"))
  (def sig (ffi/signature :default :int :int :ulong :ptr))
  #
  (def buf (ffi/write winsize [0 0 0 0]))
  #
  (def ioctl-res
    (ffi/call ioctl sig 0 ioctl-const buf))
  # =>
  #0
  (unless (= -1 ioctl-res)
    (def [rows cols _ _]
      (ffi/read winsize buf))
    #
    [rows cols]))

(defn t/via-shell
  [os]
  (def cmd
    (if (= :windows os)
      ["powershell" "-command" "&{(get-host).ui.rawui.WindowSize;}"]
      ["stty" "size"]))
  (def [left right]
    (with [f (file/temp)]
      (os/execute cmd :p {:out f})
      (file/seek f :set 0)
      (def out (file/read f :all))
      (->> (string/trim out)
           (string/split "\n")
           last
           string/trim
           (peg/match ~(sequence (number :d+) :s+ (number :d+))))))
  (if (= :windows os)
    [right left]
    [left right]))

(defn t/rows-and-cols
  []
  (def os (os/which))
  (def arch (os/arch))

  (cond
    # some from: https://github.com/olekukonko/ts
    (def tiocgwinsz
      (get {:dragonfly 0x40087468
            :freebsd 0x40087468
            :linux 0x5413
            :macos 0x40087468
            :netbsd 0x40087468
            :openbsd 0x40087468} os))
    (if (= :x64 arch)
      (t/via-ioctl tiocgwinsz)
      (t/via-shell os))
    #
    (or (= :windows os)
        (= :mingw os))
    (if (= :x64 arch)
      (t/via-winapi)
      (t/via-shell os))
    #
    (get {:bsd true
          :cygwin true
          # XXX: file/temp doesn't work for :mingw atm?
          #:mingw true
          :posix true} os)
    (t/via-shell os)
    #
    (= :web os)
    (errorf "emscripten unsupported")
    #
    (errorf "Unsupported os: %s" os)))

(defn t/rows
  []
  (get (t/rows-and-cols) 0))

(defn t/cols
  []
  (get (t/rows-and-cols) 1))



(defn doc/normal-doc
  [content]
  (def lines
    (string/split "\n" content))
  (when (empty? (array/peek lines))
    (array/pop lines))
  (def doc-lines
    (keep |(or (first
                 (peg/match ~(sequence "# " (capture (to -1)))
                            $))
               "")
          lines))
  (string/join doc-lines "\n"))

# assumes example file has certain structure
(defn doc/massage-lines-for-doc
  [lines]
  (def m-lines @[])
  (var i 0)
  # skip first line if import
  (when (peg/match ~(sequence "(import")
                   (first lines))
    (++ i))
  (while (< i (length lines))
    (def cur-line (get lines i))
    # stop at first (comment ...) form
    (if (peg/match ~(sequence "(comment")
                     cur-line)
      (break)
      (if (string/has-prefix? "# " cur-line)
        (array/push m-lines (string/slice cur-line 2))
        (array/push m-lines cur-line)))
    (++ i))
  #
  m-lines)

(defn doc/special-doc
  [content &opt width indent]
  (def cols
    (if-let [cols (t/cols)]
      cols
      80))
  (default width (+ 8 (dyn :pdoc-width cols)))
  (default indent 0)
  (def lines
    (string/split "\n" content))
  (def doc-lines
    (doc/massage-lines-for-doc lines))
  # XXX: issue with doc-format?
  #      width doesn't seem to work as-is as a value very well
  (doc-format (string/join doc-lines "\n") width indent))



# XXX: not sure if this quoting will work on windows...
(defn s/escape
  [a-str]
  (string "\""
          a-str
          "\""))

(defn s/all-names
  [names]
  # print all names
  (each name (sort names)
    # XXX: anything missing?
    # XXX: anything platform-specific?
    (if (get {"*" true
              "->" true
              ">" true
              "<-" true}
             name)
      (print (s/escape name))
      (print name))))

(defn s/normal-doc
  [content]
  '(each line (doc/normal-doc content)
    (print line))
  (print (doc/normal-doc content)))

(defn s/special-doc
  [content &opt width indent]
  (print (doc/special-doc content width indent)))

########################################################################

(comment import ./highlight :prefix "")
(comment import ./grammar :prefix "")
(def g/jg
  ~@{:main (some :input)
     #
     :input (choice :non-form
                    :form)
     #
     :non-form (choice :whitespace
                       :comment)
     #
     :whitespace (choice (some (set " \0\f\t\v"))
                         (choice "\r\n"
                                 "\r"
                                 "\n"))
     #
     :comment (sequence "#"
                        (any (if-not (set "\r\n") 1)))
     #
     :form (choice :reader-macro
                   :collection
                   :literal)
     #
     :reader-macro (choice :fn
                           :quasiquote
                           :quote
                           :splice
                           :unquote)
     #
     :fn (sequence "|"
                   (any :non-form)
                   :form)
     #
     :quasiquote (sequence "~"
                           (any :non-form)
                           :form)
     #
     :quote (sequence "'"
                      (any :non-form)
                      :form)
     #
     :splice (sequence ";"
                       (any :non-form)
                       :form)
     #
     :unquote (sequence ","
                        (any :non-form)
                        :form)
     #
     :literal (choice :number
                      :constant
                      :buffer
                      :string
                      :long-buffer
                      :long-string
                      :keyword
                      :symbol)
     #
     :collection (choice :array
                         :bracket-array
                         :tuple
                         :bracket-tuple
                         :table
                         :struct)
     #
     :number (drop (sequence (cmt (capture (some :num-char))
                                  ,scan-number)
                             (opt (sequence ":" (range "AZ" "az")))))
     #
     :num-char (choice (range "09" "AZ" "az")
                       (set "&+-._"))
     #
     :constant (sequence (choice "false" "nil" "true")
                         (not :name-char))
     #
     :name-char (choice (range "09" "AZ" "az" "\x80\xFF")
                        (set "!$%&*+-./:<?=>@^_"))
     #
     :buffer (sequence `@"`
                       (any (choice :escape
                                    (if-not `"` 1)))
                       `"`)
     #
     :escape (sequence `\`
                       (choice (set `"'0?\abefnrtvz`)
                               (sequence "x" [2 :h])
                               (sequence "u" [4 :h])
                               (sequence "U" [6 :h])
                               (error (constant "bad escape"))))
     #
     :string (sequence `"`
                       (any (choice :escape
                                    (if-not `"` 1)))
                       `"`)
     #
     :long-string :long-bytes
     #
     :long-bytes {:main (drop (sequence :open
                                        (any (if-not :close 1))
                                        :close))
                  :open (capture :delim :n)
                  :delim (some "`")
                  :close (cmt (sequence (not (look -1 "`"))
                                        (backref :n)
                                        (capture (backmatch :n)))
                              ,=)}
     #
     :long-buffer (sequence "@"
                            :long-bytes)
     #
     :keyword (sequence ":"
                        (any :name-char))
     #
     :symbol (some :name-char)
     #
     :array (sequence "@("
                      (any :input)
                      (choice ")"
                              (error (constant "missing )"))))
     #
     :tuple (sequence "("
                      (any :input)
                      (choice ")"
                              (error (constant "missing )"))))
     #
     :bracket-array (sequence "@["
                              (any :input)
                              (choice "]"
                                      (error (constant "missing ]"))))
     #
     :bracket-tuple (sequence "["
                              (any :input)
                              (choice "]"
                                      (error (constant "missing ]"))))
     :table (sequence "@{"
                      (any :input)
                      (choice "}"
                              (error (constant "missing }"))))
     #
     :struct (sequence "{"
                       (any :input)
                       (choice "}"
                               (error (constant "missing }"))))
     })

(comment

  (peg/match g/jg "")
  # =>
  nil

  (peg/match g/jg "11")
  # =>
  @[]

  (peg/match g/jg "0xff")
  # =>
  @[]

  (peg/match g/jg "1:u")
  # =>
  @[]

  (peg/match g/jg "-2:s")
  # =>
  @[]

  (peg/match g/jg "1e2:n")
  # =>
  @[]

  (peg/match g/jg "0x2.8FaP11")
  # =>
  @[]

  (peg/match g/jg "@\"i am a buffer\"")
  # =>
  @[]

  (peg/match g/jg "# hello")
  # =>
  @[]

  (peg/match g/jg "``hello``")
  # =>
  @[]

  (peg/match g/jg "|(+ $ 2)")
  # =>
  @[]

  (peg/match g/jg "[1 2]")
  # =>
  @[]

  (peg/match g/jg "@{:a 1}")
  # =>
  @[]

  (peg/match g/jg "[:a :b] 1")
  # =>
  @[]

  (try
    (peg/match g/jg "[:a :b)")
    ([e] e))
  # =>
  "missing ]"

  (try
    (peg/match g/jg "(def a # hi 1)")
    ([e] e))
  # =>
  "missing )"

  (try
    (peg/match g/jg "\"\\u001\"")
    ([e] e))
  # =>
  "bad escape"

  )


(def hl/m/none
  [nil])

(defn hl/m/mono-str
  [text _ignored]
  text)

(defn hl/m/mono-prin
  [msg _color]
  (prin msg))

(def hl/m/mono-separator-color
  hl/m/none)

(def hl/color/red :red)

(def hl/color/yellow :yellow)

(def hl/color/green :green)

(def hl/color/blue :blue)

(def hl/color/cyan :cyan)

(def hl/color/magenta :magenta)

(def hl/color/white :white)

(def hl/color/black :black)

(def hl/color/none nil)

(defn hl/color/color-str
  [msg color]
  (if color
    (let [color-num (match color
                      :black 30
                      :blue 34
                      :cyan 36
                      :green 32
                      :magenta 35
                      :red 31
                      :white 37
                      :yellow 33)]
      (string "\e[" color-num "m"
              msg
              "\e[0m"))
    msg))

(defn hl/color/color-prin
  [msg color]
  (prin (hl/color/color-str msg color)))

(def hl/color/color-separator-color hl/color/blue)

# color names (except "none") from M-x list-colors-display

(def hl/rgb/red [0xff 0x00 0x00])

(def hl/rgb/dark-orange
  [0xff 0x8c 0x00])

(def hl/rgb/yellow
  [0xff 0xff 0x00])

(def hl/rgb/chartreuse
  [0x7f 0xff 0x00])

(def hl/rgb/cyan
  [0x00 0xff 0xff])

(def hl/rgb/blue
  [0x00 0x00 0xff])

(def hl/rgb/purple
  [0xa0 0x20 0xf0])

(def hl/rgb/magenta
  [0xff 0x00 0xff])

(def hl/rgb/white
  [0xff 0xff 0xff])

(def hl/rgb/none
  [nil nil nil])

(defn hl/rgb/rgb-str
  [text [r g b]]
  (if (nil? r)
    text
    # https://en.wikipedia.org/wiki/ANSI_escape_code#24-bit
    # ESC[38;2;⟨r⟩;⟨g⟩;⟨b⟩ m Select RGB foreground color     # ] <- hack
    (string "\e[38;2;" r ";" g ";" b "m"
            text
            "\e[0m")))

(defn hl/rgb/rgb-prin
  [msg [r g b]]
  (prin (hl/rgb/rgb-str msg [r g b])))

(def hl/rgb/rgb-separator-color hl/rgb/blue)

(defn hl/rgb-theme
  [node-type]
  (cond
    (= :constant node-type)
    hl/rgb/magenta
    #
    (= :symbol node-type)
    hl/rgb/chartreuse
    #
    (= :keyword node-type)
    hl/rgb/magenta
    #
    (= :string node-type)
    hl/rgb/yellow
    #
    (= :number node-type)
    hl/rgb/cyan
    #
    hl/rgb/none))

(defn hl/color-theme
  [node-type]
  (cond
    (= :constant node-type)
    hl/color/magenta
    #
    (= :symbol node-type)
    hl/color/green
    #
    (= :keyword node-type)
    hl/color/magenta
    #
    (= :string node-type)
    hl/color/yellow
    #
    (= :number node-type)
    hl/color/cyan
    #
    hl/color/none))

(defn hl/mono-theme
  [_]
  hl/m/none)

(def hl/jg-capture-ast
  # jg is a struct, need something mutable
  (let [jca (table ;(kvs g/jg))]
    # override things that need to be captured
    (each kwd [:buffer :comment :constant :keyword :long-buffer
               :long-string :number :string :symbol :whitespace]
      (put jca kwd
               ~(cmt (capture ,(in jca kwd))
                     ,|[kwd $])))
    (each kwd [:fn :quasiquote :quote :splice :unquote]
      (put jca kwd
               ~(cmt (capture ,(in jca kwd))
                     ,|[kwd ;(slice $& 0 -2)])))
    (each kwd [:array :bracket-array :bracket-tuple :table :tuple :struct]
      (put jca kwd
           (tuple # array needs to be converted
                  ;(put (array ;(in jca kwd))
                        2 ~(cmt (capture ,(get-in jca [kwd 2]))
                                ,|[kwd ;(slice $& 0 -2)])))))
    # tried using a table with a peg but had a problem, so use a struct
    (table/to-struct jca)))

(comment

  (peg/match hl/jg-capture-ast "")
  # =>
  nil

  (peg/match hl/jg-capture-ast ".0")
  # =>
  @[[:number ".0"]]

  (peg/match hl/jg-capture-ast "@\"i am a buffer\"")
  # =>
  @[[:buffer "@\"i am a buffer\""]]

  (peg/match hl/jg-capture-ast "# hello")
  # =>
  @[[:comment "# hello"]]

  (peg/match hl/jg-capture-ast ":a")
  # =>
  @[[:keyword ":a"]]

  (peg/match hl/jg-capture-ast "@``i am a long buffer``")
  # =>
  @[[:long-buffer "@``i am a long buffer``"]]

  (peg/match hl/jg-capture-ast "``hello``")
  # =>
  @[[:long-string "``hello``"]]

  (peg/match hl/jg-capture-ast "\"\\u0001\"")
  # =>
  @[[:string "\"\\u0001\""]]

  (peg/match hl/jg-capture-ast "|(+ $ 2)")
  # =>
  '@[(:fn
       (:tuple
         (:symbol "+") (:whitespace " ")
         (:symbol "$") (:whitespace " ")
         (:number "2")))]

  (peg/match hl/jg-capture-ast "@{:a 1}")
  # =>
  '@[(:table
       (:keyword ":a") (:whitespace " ")
       (:number "1"))]

  )

(def hl/jg-capture-top-level-ast
  # jg is a struct, need something mutable
  (let [jca (table ;(kvs hl/jg-capture-ast))]
    (put jca
         :main ~(sequence :input (position)))
    # tried using a table with a peg but had a problem, so use a struct
    (table/to-struct jca)))

(defn hl/par
  [src &opt start single]
  (default start 0)
  (if single
    (if-let [[tree position]
             (peg/match hl/jg-capture-top-level-ast src start)]
      [@[:code tree] position]
      [@[:code] nil])
    (if-let [tree (peg/match hl/jg-capture-ast src start)]
      (array/insert tree 0 :code)
      @[:code])))

(comment

  (hl/par "(+ 1 1)")
  # =>
  '@[:code
     (:tuple
       (:symbol "+") (:whitespace " ")
       (:number "1") (:whitespace " ")
       (:number "1"))]

  )

(defn hl/gen*
  [an-ast buf]
  (case (first an-ast)
    :code
    (each elt (drop 1 an-ast)
      (hl/gen* elt buf))
    #
    :buffer
    (buffer/push-string buf ((dyn :pdoc-hl-str hl/m/mono-str)
                              (in an-ast 1)
                              ((dyn :pdoc-theme hl/mono-theme) :buffer)))
    :comment
    (buffer/push-string buf ((dyn :pdoc-hl-str hl/m/mono-str)
                              (in an-ast 1)
                              ((dyn :pdoc-theme hl/mono-theme) :comment)))
    :constant
    (buffer/push-string buf ((dyn :pdoc-hl-str hl/m/mono-str)
                              (in an-ast 1)
                              ((dyn :pdoc-theme hl/mono-theme) :constant)))
    :keyword
    (buffer/push-string buf ((dyn :pdoc-hl-str hl/m/mono-str)
                              (in an-ast 1)
                              ((dyn :pdoc-theme hl/mono-theme) :keyword)))
    :long-buffer
    (buffer/push-string buf ((dyn :pdoc-hl-str hl/m/mono-str)
                              (in an-ast 1)
                              ((dyn :pdoc-theme hl/mono-theme) :long-buffer)))
    :long-string
    (buffer/push-string buf ((dyn :pdoc-hl-str hl/m/mono-str)
                              (in an-ast 1)
                              ((dyn :pdoc-theme hl/mono-theme) :long-string)))
    :number
    (buffer/push-string buf ((dyn :pdoc-hl-str hl/m/mono-str)
                              (in an-ast 1)
                              ((dyn :pdoc-theme hl/mono-theme) :number)))
    :string
    (buffer/push-string buf ((dyn :pdoc-hl-str hl/m/mono-str)
                              (in an-ast 1)
                              ((dyn :pdoc-theme hl/mono-theme) :string)))
    :symbol
    (buffer/push-string buf ((dyn :pdoc-hl-str hl/m/mono-str)
                              (in an-ast 1)
                              ((dyn :pdoc-theme hl/mono-theme) :symbol)))
    :whitespace
    (buffer/push-string buf (in an-ast 1))
    #
    :array
    (do
      (buffer/push-string buf "@(")
      (each elt (drop 1 an-ast)
        (hl/gen* elt buf))
      (buffer/push-string buf ")"))
    :bracket-array
    (do
      (buffer/push-string buf "@[")
      (each elt (drop 1 an-ast)
        (hl/gen* elt buf))
      (buffer/push-string buf "]"))
    :bracket-tuple
    (do
      (buffer/push-string buf "[")
      (each elt (drop 1 an-ast)
        (hl/gen* elt buf))
      (buffer/push-string buf "]"))
    :tuple
    (do
      (buffer/push-string buf "(")
      (each elt (drop 1 an-ast)
        (hl/gen* elt buf))
      (buffer/push-string buf ")"))
    :struct
    (do
      (buffer/push-string buf "{")
      (each elt (drop 1 an-ast)
        (hl/gen* elt buf))
      (buffer/push-string buf "}"))
    :table
    (do
      (buffer/push-string buf "@{")
      (each elt (drop 1 an-ast)
        (hl/gen* elt buf))
      (buffer/push-string buf "}"))
    #
    :fn
    (do
      (buffer/push-string buf "|")
      (each elt (drop 1 an-ast)
        (hl/gen* elt buf)))
    :quasiquote
    (do
      (buffer/push-string buf "~")
      (each elt (drop 1 an-ast)
        (hl/gen* elt buf)))
    :quote
    (do
      (buffer/push-string buf "'")
      (each elt (drop 1 an-ast)
        (hl/gen* elt buf)))
    :splice
    (do
      (buffer/push-string buf ";")
      (each elt (drop 1 an-ast)
        (hl/gen* elt buf)))
    :unquote
    (do
      (buffer/push-string buf ",")
      (each elt (drop 1 an-ast)
        (hl/gen* elt buf)))
    ))

(defn hl/gen
  [an-ast]
  (let [buf @""]
    (hl/gen* an-ast buf)
    (string buf)))

(comment

  (hl/gen
    [:code])
  # =>
  ""

  (hl/gen
    [:code
     [:buffer "@\"buffer me\""]])
  # =>
  `@"buffer me"`

  (hl/gen
    [:comment "# i am a comment"])
  # =>
  "# i am a comment"

  (hl/gen
    [:long-string "```longish string```"])
  # =>
  "```longish string```"

  (hl/gen
    '(:fn
       (:tuple
         (:symbol "-") (:whitespace " ")
         (:symbol "$") (:whitespace " ")
         (:number "8"))))
  # =>
  "|(- $ 8)"

  (hl/gen
    '(:array
       (:keyword ":a") (:whitespace " ")
       (:keyword ":b")))
  # =
  "@(:a :b)"

  (hl/gen
    '@(:struct
       (:keyword ":a") (:whitespace " ")
       (:number "1")))
  # =>
  "{:a 1}"

  )

(defn hl/colorize
  [src]
  (hl/gen (hl/par src)))

(comment

  (def src "{:x  :y \n :z  [:a  :b    :c]}")

  (hl/colorize src)

  (def src-2 "(peg/match ~(any \"a\") \"abc\")")

  (hl/colorize src-2)

  )


(comment import ./indent :prefix "")
### based on spork/fmt by bakpakin

### hint for comprehension
###
### study the call to `flushwhite` in `fmt-1` and everything
### that exists to support it

(defn indent/pnode
  "Make a capture function for a node."
  [tag]
  (fn [x] [tag x]))

# all nodes except one have the form:
#
#   [:tag-name ...]
#
# the sole exception is the node for a newline which is:
#
#   "\n"
#
# there are 3 kinds of non-newline whitespace:
#
# 1. :ws-bi - before indentation (leading whitespace)
# 2. :ws-tr - after last non-whitespace (trailing whitespace)
# 3. :ws    - there is non-whitespace somewhere to the left and right
#
# example:
#
# bol   (+ 1 1)   eol
#    ^^^  ^    ^^^
#     |   |     |
#     |  :ws    |
#     |      :ws-tr
#  :ws-bi
#
# bol stands for beginning of line
# eol stands for end of line
(defn indent/make-tree
  "Turn a string of source code into a tree that will be printed"
  [source]
  (var bi true)
  #
  (def parse-peg
    "Peg to parse Janet with extra information, namely comments."
    (peg/compile
      ~{:nl "\n"
        :ws (cmt (sequence (capture (some (set " \t\r\f\0\v")))
                           (look 0 (choice -1
                                           (capture 1))))
                 ,(fn [& args]
                    (def ws (get args 0))
                    (cond
                      (and bi
                           (= 2 (length args))
                           (not= "\n" (get args 1)))
                      [:ws-bi ws]
                      #
                      (= 1 (length args))
                      [:ws-tr ws]
                      #
                      (= 2 (length args))
                      (if (= "\n" (get args 1))
                        [:ws-tr ws]
                        [:ws ws])
                      #
                      (do
                        (eprintf "unexpected ws info: %p %p"
                                 args (length args))
                        (error "unexpected input")))))
        :readermac (set "';~,|")
        :symchars (choice (range "09" "AZ" "az" "\x80\xFF")
                          (set "!$%&*+-./:<?=>@^_"))
        :token (some :symchars)
        :escape
        (sequence "\\" (choice (set `"'0?\abefnrtvz`)
                               (sequence "x" (2 :h))
                               (sequence "u" (4 :h))
                               (sequence "U" (6 :h))
                               (error (constant "bad hex escape"))))
        :comment (replace (sequence "#"
                                    (capture (to (choice "\n" -1))))
                          ,(indent/pnode :comment))
        :span (replace (capture :token)
                       ,(indent/pnode :span))
        :bytes (capture (sequence `"`
                                  (any (choice :escape
                                               (if-not `"` 1)))
                                  `"`))
        :string (replace :bytes ,(indent/pnode :string))
        :buffer (replace (sequence "@" :bytes)
                         ,(indent/pnode :buffer))
        :long-bytes
        (capture {:delim (some "`")
                  :open (capture :delim :n)
                  :close (cmt (sequence (not (look -1 "`"))
                                        (backref :n)
                                        (capture :delim))
                              ,=)
                  :main (drop (sequence :open
                                        (any (if-not :close 1))
                                        :close))})
        :long-string (replace :long-bytes ,(indent/pnode :string))
        :long-buffer (replace (sequence "@" :long-bytes)
                              ,(indent/pnode :buffer))
        :ptuple (replace (group (sequence "("
                                          (any :input)
                                          (choice ")" (error))))
                         ,(indent/pnode :ptuple))
        :btuple (replace (group (sequence "["
                                          (any :input)
                                          (choice "]" (error))))
                         ,(indent/pnode :btuple))
        :struct (replace (group (sequence "{"
                                          (any :input)
                                          (choice "}" (error))))
                         ,(indent/pnode :struct))
        :parray (replace (group (sequence "@("
                                          (any :input)
                                          (choice ")" (error))))
                         ,(indent/pnode :array))
        :barray (replace (group (sequence "@["
                                          (any :input)
                                          (choice "]" (error))))
                         ,(indent/pnode :array))
        :table (replace (group (sequence "@{"
                                         (any :input)
                                         (choice "}" (error))))
                        ,(indent/pnode :table))
        :rmform (replace (group (sequence ':readermac
                                          (group (any :non-form))
                                          :form))
                         ,(indent/pnode :rmform))
        :unreadable (replace
                      (capture
                        (sequence "<"
                                  (between 1 32 :symchars)
                                  :s+
                                  (some (if (choice :symchars
                                                    :d)
                                          1))
                                  (look -1 ">")
                                  (look 0 (choice -1
                                                  (not (choice :symchars
                                                               :d))))))
                      ,(indent/pnode :unreadable))
        :form
        (sequence (drop (cmt (constant "smile")
                             ,(fn [& args]
                                (set bi false)
                                true)))
                  (choice :unreadable
                          :rmform
                          :parray :barray :ptuple :btuple :table :struct
                          :buffer :string :long-buffer :long-string
                          :span))
        :non-form
        (choice :ws
                # :nl
                (cmt (capture :nl)
                     ,(fn [& args]
                        (set bi true)
                        (first args)))
                # :comment
                (sequence (drop (cmt (constant "smile")
                                     ,(fn [& args]
                                        (set bi false)
                                        true)))
                          :comment))
        :input
        (choice :non-form
                (cmt (capture :form)
                     ,(fn [& args]
                        (set bi false)
                        (first args))))
        :main (sequence (any :input)
                        (choice -1 (error)))}))
  #
  [:top (peg/match parse-peg source)])

(comment

  (indent/make-tree "# hello\n")
  # =>
  '(:top @[(:comment " hello") "\n"])

  (indent/make-tree "(+ 1 1)")
  # =>
  '(:top
     @[(:ptuple
         @[(:span "+") (:ws " ")
           (:span "1") (:ws " ")
           (:span "1")])])

  (indent/make-tree " (+ 1 1) ")
  # =>
  '(:top
     @[(:ws-bi " ")
       (:ptuple
         @[(:span "+") (:ws " ")
           (:span "1") (:ws " ")
           (:span "1")])
       (:ws-tr " ")])

  (indent/make-tree
    (string "(comment\n"
            "\n"
            "  :hi\n"
            "  #\n"
            "  )"))
  # =>
  '(:top
     @[(:ptuple
         @[(:span "comment") "\n"
           "\n"
           (:ws-bi "  ") (:span ":hi") "\n"
           (:ws-bi "  ") (:comment "") "\n"
           (:ws-bi "  ")])])

  (indent/make-tree
    (string "(do \n"
            "(def _0000by \n"
            "[0 1 2]) \n"
            "(var _0000bx \n"
            "(<function next> _0000by nil)) \n"
            "(while (<function not=> nil _0000bx) \n"
            "(def i \n"
            "(<function in> _0000by _0000bx)) \n"
            "(break) \n"
            "(set _0000bx \n"
            "(<function next> _0000by _0000bx))))"))
  # =>
  '(:top
     @[(:ptuple
         @[(:span "do") (:ws-tr " ") "\n"
           (:ptuple
             @[(:span "def") (:ws " ")
               (:span "_0000by") (:ws-tr " ") "\n"
               (:btuple
                 @[(:span "0") (:ws " ")
                   (:span "1") (:ws " ")
                   (:span "2")])]) (:ws-tr " ") "\n"
           (:ptuple
             @[(:span "var") (:ws " ")
               (:span "_0000bx") (:ws-tr " ") "\n"
               (:ptuple
                 @[(:unreadable "<function next>") (:ws " ")
                   (:span "_0000by") (:ws " ")
                   (:span "nil")])]) (:ws-tr " ") "\n"
           (:ptuple
             @[(:span "while") (:ws " ")
               (:ptuple
                 @[(:unreadable "<function not=>") (:ws " ")
                   (:span "nil") (:ws " ")
                   (:span "_0000bx")]) (:ws-tr " ") "\n"
               (:ptuple
                 @[(:span "def") (:ws " ")
                   (:span "i") (:ws-tr " ") "\n"
                   (:ptuple
                     @[(:unreadable "<function in>") (:ws " ")
                       (:span "_0000by") (:ws " ")
                       (:span "_0000bx")])]) (:ws-tr " ") "\n"
               (:ptuple
                 @[(:span "break")]) (:ws-tr " ") "\n"
               (:ptuple
                 @[(:span "set") (:ws " ")
                   (:span "_0000bx") (:ws-tr " ") "\n"
                   (:ptuple
                     @[(:unreadable "<function next>") (:ws " ")
                       (:span "_0000by") (:ws " ")
                       (:span "_0000bx")])])])])])

  )

# added `comment`
(def indent/indent-2-forms
  "A list of forms that are control forms and should be indented two spaces."
  (invert ["case" "catseq" "comment" "compif" "compwhen" "cond" "coro"
           "def" "def-" "default" "defer" "defglobal" "defmacro" "defmacro-"
           "defn" "defn-" "do"
           "each" "eachp" "eachk" "eachy" "edefer" "ev/do-thread" "ev/spawn"
           "ev/with-deadline"
           "fn" "for" "forever" "forv"
           "generate"
           "if" "if-let" "if-not" "if-with"
           "label" "let" "loop"
           "match"
           "prompt"
           "repeat"
           "seq" "short-fn"
           "tabseq" "try"
           "unless" "upscope"
           "var" "varfn" "varglobal" "var-"
           "when" "when-let" "when-with" "while" "with" "with-dyns"
           "with-syms" "with-vars"]))

(def indent/indent-2-peg
  "Peg to use to fuzzy match certain forms."
  (peg/compile ~(choice "with-" "def" "if-" "when-")))

(defn indent/first-non-ws-is-nl?
  [xs]
  (var result nil)
  (each x xs
    (when (= "\n" x)
      (set result true)
      (break))
    (when-let [[tag _] x]
      (when (and (not= :ws-bi tag)
                 (not= :ws tag)
                 (not= :ws-tr tag))
        (break false))))
  (truthy? result))

(comment

  (indent/first-non-ws-is-nl? ["\n" [:ws " "]])
  # =>
  true

  (indent/first-non-ws-is-nl? [[:ws " "] "\n" [:ws " "]])
  # =>
  true

  (indent/first-non-ws-is-nl? [[:ws-bi " "] "\n" [:ws " "]])
  # =>
  true

  (indent/first-non-ws-is-nl? [[:ws-tr " "] "\n" [:ws " "]])
  # =>
  true

  (indent/first-non-ws-is-nl? [[:comment " hi"] "\n" [:ws " "]])
  # =>
  false

  )

(defn indent/check-indent-2
  "Check if a tuple needs a 2 space indent or not"
  [items]
  (if-let [[tag body] (get items 0)]
    (cond
      (indent/first-non-ws-is-nl? (slice items 1)) true
      (not= tag :span) nil
      (in indent/indent-2-forms body) true
      (peg/match indent/indent-2-peg body) true)))

(defn indent/check-data-indent
  "Check if a tuple should be formatted as data"
  [items]
  (when-let [[head-node] items]
    (match head-node
      "\n" true
      [:comment _] true
      [:ws _] true
      # XXX: can these happen?
      [:ws-bi _] true
      [:ws-tr _] true)))

(defn indent/non-nls
  [xs]
  (filter |(not= $ "\n") xs))

(defn indent/has-nl?
  [xs]
  (truthy? (find |(= $ "\n") xs)))

(defn indent/fmt
  "Emit formatted."
  [tree]

  # tracks current column based on emitted content
  #   modified by `emit` and `newline`
  #   mostly used by `indent`
  #   also used by `emit-body` and `emit-funcall` for some edge cases
  (var col 0)

  # stack for saving / restoring `white`
  #   manipulated by `indent` and `dedent`
  (def ident-stack @[])

  # what `white` is reset to when `newline` is called
  #   also is saved/restored to/from `ident-stack`
  (var ident "")

  # whitespace that will be output via `flushwhite`
  #   manipulated directly by `flushwhite`, `dropwhite`, `newline`
  #   also indirectly via `dropwhite` by:
  #     `newline`
  #     `emit-body`
  #     `emit-funcall`
  #     `emit-string`
  (def white @"")

  # `emit` and `newline` are the only things that output directly
  # (`fmt-1` now directly outputs trailing whitespace)
  #
  # `emit` is called by:
  #   `flushwhite`
  #   `emit-body`
  #   `emit-funcall``
  #   `emit-string`
  #   `emit-rmform`
  #   `fmt-1`
  #
  # `newline` is called by:
  #   `emit-string`
  #   `fmt-1`
  #
  # `fmt-1` is the only caller of:
  #   `flushwhite`
  #   `emit-body`
  #   `emit-funcall`
  #   `emit-string`
  #   `emit-rmform`

  (defn emit [& xs]
    (each x xs
      # parsed content contains delimiters (e.g. strings include "s)
      (+= col (length x))
      (prin x)))

  (defn indent [&opt delta]
    (array/push ident-stack ident)
    (set ident
         (string/repeat " " (+ col (or delta 0)))))

  (defn dedent []
    (set ident
         (array/pop ident-stack)))

  (defn flushwhite []
    (emit white)
    (buffer/clear white))

  (defn dropwhite []
    (buffer/clear white))

  (defn newline []
    (dropwhite)
    (print)
    (buffer/push-string white ident)
    (set col 0))

  # Mutual recursion
  (var fmt-1-recur nil)

  (defn emit-body
    [open xs close &opt delta top]
    (def od-col col)
    (emit open)
    #
    (indent delta)
    (each x xs (fmt-1-recur x))
    (dropwhite)
    (dedent)
    # XXX: messy part
    (when (not top)
      (cond
        # empty container case
        (and (indent/has-nl? xs) (zero? (length (indent/non-nls xs))))
        (emit (tracev (string/repeat " " (+ od-col 1))))
        # XXX: actually want alignment with opening delimiter
        #      of 2nd non-ws, non-comment child?
        (zero? col)
        (emit (string/repeat " "
                             (+ od-col 1 (or delta 0))))))
    #
    (emit close))

  (defn emit-funcall
    [xs]
    (def od-col col)
    (emit "(")
    #
    (def len (length xs))
    (when (pos? len)
      (fmt-1-recur (xs 0))
      (indent 1)
      (for i 1 len (fmt-1-recur (xs i)))
      (dropwhite)
      (dedent))
    # XXX: messy part
    (cond
      # empty tuple case
      (and (indent/has-nl? xs) (zero? (length (indent/non-nls xs))))
      (emit (string/repeat " " (+ od-col 1)))
      # XXX: actually want alignment with opening delimiter
      #      of 2nd non-ws, non-comment child?
      (zero? col)
      (emit (string/repeat " " (+ od-col 1))))
    #
    (emit ")"))

  (defn emit-string
    [x]
    (def parts
      (interpose "\n" (string/split "\n" x)))
    (each p parts
      (if (= p "\n")
        (do (newline) (dropwhite))
        (emit p))))

  (defn emit-rmform
    [rm nfs form]
    (emit rm)
    (each nf nfs
      (fmt-1-recur nf))
    (fmt-1-recur form))

  (defn fmt-1
    [node]
    # insert appropriate whitespace
    (when (and (not= "\n" node)
               (not= :ws-tr (get node 0)))
      (flushwhite))
    # node-specific "emission"
    (match node
      "\n" (newline)
      [:ws-bi x] (prin "")
      [:ws x] (emit x)
      [:ws-tr x] (prin x)
      [:comment x] (emit "#" x)
      [:span x] (emit x)
      [:string x] (emit-string x)
      [:buffer x] (do (emit "@") (emit-string x))
      [:array xs] (emit-body "@[" xs "]")
      [:btuple xs] (emit-body "[" xs "]")
      [:ptuple xs] (cond
                     (indent/check-data-indent xs)
                     (emit-body "(" xs ")")
                     #
                     (indent/check-indent-2 xs)
                     (emit-body "(" xs ")" 1)
                     #
                     (emit-funcall xs))
      [:struct xs] (emit-body "{" xs "}")
      [:table xs] (emit-body "@{" xs "}")
      [:rmform [rm nfs form]] (emit-rmform rm nfs form)
      [:unreadable x] (emit x)
      [:top xs] (emit-body "" xs "" nil true)))

  (set fmt-1-recur fmt-1)
  (fmt-1 tree)
  (flush))

#
# Public API
#

(defn indent/format-print
  "Format a string of source code and print the result."
  [source]
  (-> source indent/make-tree indent/fmt))

(defn indent/format
  "Format a string of source code to a buffer."
  [source]
  (def out @"")
  (with-dyns [:out out]
    (indent/format-print source))
  out)

(comment

  (indent/format
    ``
    (do
    (def _0000by
    [0 1 2])
    (var _0000bx
    (<function next> _0000by nil))
    (while (<function not=> nil _0000bx)
    (def i
    (<function in> _0000by _0000bx))
    (break)
    (set _0000bx
    (<function next> _0000by _0000bx))))
    ``)
  # =>
  @``
   (do
     (def _0000by
       [0 1 2])
     (var _0000bx
       (<function next> _0000by nil))
     (while (<function not=> nil _0000bx)
       (def i
         (<function in> _0000by _0000bx))
       (break)
       (set _0000bx
            (<function next> _0000by _0000bx))))
   ``
  )

(defn indent/format-file
  "Format a file"
  [file]
  (def source (slurp file))
  (def out (indent/format source))
  (spit file out))

(comment import ./parse :prefix "")
(comment import ./location :prefix "")
# bl - begin line
# bc - begin column
# el - end line
# ec - end column
(defn l/make-attrs
  [& items]
  (zipcoll [:bl :bc :el :ec]
           items))

(defn l/atom-node
  [node-type peg-form]
  ~(cmt (capture (sequence (line) (column)
                           ,peg-form
                           (line) (column)))
        ,|[node-type (l/make-attrs ;(slice $& 0 -2)) (last $&)]))

(defn l/reader-macro-node
  [node-type sigil]
  ~(cmt (capture (sequence (line) (column)
                           ,sigil
                           (any :non-form)
                           :form
                           (line) (column)))
        ,|[node-type (l/make-attrs ;(slice $& 0 2) ;(slice $& -4 -2))
           ;(slice $& 2 -4)]))

(defn l/collection-node
  [node-type open-delim close-delim]
  ~(cmt
     (capture
       (sequence
         (line) (column)
         ,open-delim
         (any :input)
         (choice ,close-delim
                 (error
                   (replace (sequence (line) (column))
                            ,|(string/format
                                "line: %p column: %p missing %p for %p"
                                $0 $1 close-delim node-type))))
         (line) (column)))
     ,|[node-type (l/make-attrs ;(slice $& 0 2) ;(slice $& -4 -2))
        ;(slice $& 2 -4)]))

(def l/loc-grammar
  ~@{:main (sequence (line) (column)
                     (some :input)
                     (line) (column))
     #
     :input (choice :non-form
                    :form)
     #
     :non-form (choice :whitespace
                       :comment)
     #
     :whitespace ,(l/atom-node :whitespace
                             '(choice (some (set " \0\f\t\v"))
                                      (choice "\r\n"
                                              "\r"
                                              "\n")))
     # :whitespace
     # (cmt (capture (sequence (line) (column)
     #                         (choice (some (set " \0\f\t\v"))
     #                                 (choice "\r\n"
     #                                         "\r"
     #                                         "\n"))
     #                         (line) (column)))
     #      ,|[:whitespace (make-attrs ;(slice $& 0 -2)) (last $&)])
     #
     :comment ,(l/atom-node :comment
                          '(sequence "#"
                                     (any (if-not (set "\r\n") 1))))
     #
     :form (choice # reader macros
                   :fn
                   :quasiquote
                   :quote
                   :splice
                   :unquote
                   # collections
                   :array
                   :bracket-array
                   :tuple
                   :bracket-tuple
                   :table
                   :struct
                   # atoms
                   :number
                   :constant
                   :buffer
                   :string
                   :long-buffer
                   :long-string
                   :keyword
                   :symbol)
     #
     :fn ,(l/reader-macro-node :fn "|")
     # :fn (cmt (capture (sequence (line) (column)
     #                             "|"
     #                             (any :non-form)
     #                             :form
     #                             (line) (column)))
     #          ,|[:fn (make-attrs ;(slice $& 0 2) ;(slice $& -4 -2))
     #             ;(slice $& 2 -4)])
     #
     :quasiquote ,(l/reader-macro-node :quasiquote "~")
     #
     :quote ,(l/reader-macro-node :quote "'")
     #
     :splice ,(l/reader-macro-node :splice ";")
     #
     :unquote ,(l/reader-macro-node :unquote ",")
     #
     :array ,(l/collection-node :array "@(" ")")
     # :array
     # (cmt
     #   (capture
     #     (sequence
     #       (line) (column)
     #       "@("
     #       (any :input)
     #       (choice ")"
     #               (error
     #                 (replace (sequence (line) (column))
     #                          ,|(string/format
     #                              "line: %p column: %p missing %p for %p"
     #                              $0 $1 ")" :array))))
     #       (line) (column)))
     #   ,|[:array (make-attrs ;(slice $& 0 2) ;(slice $& -4 -2))
     #      ;(slice $& 2 -4)])
     #
     :tuple ,(l/collection-node :tuple "(" ")")
     #
     :bracket-array ,(l/collection-node :bracket-array "@[" "]")
     #
     :bracket-tuple ,(l/collection-node :bracket-tuple "[" "]")
     #
     :table ,(l/collection-node :table "@{" "}")
     #
     :struct ,(l/collection-node :struct "{" "}")
     #
     :number ,(l/atom-node :number
                         ~(drop (sequence (cmt (capture (some :num-char))
                                               ,scan-number)
                                          (opt (sequence ":" (range "AZ" "az"))))))
     #
     :num-char (choice (range "09" "AZ" "az")
                       (set "&+-._"))
     #
     :constant ,(l/atom-node :constant
                           '(sequence (choice "false" "nil" "true")
                                      (not :name-char)))
     #
     :name-char (choice (range "09" "AZ" "az" "\x80\xFF")
                        (set "!$%&*+-./:<?=>@^_"))
     #
     :buffer ,(l/atom-node :buffer
                         '(sequence `@"`
                                    (any (choice :escape
                                                 (if-not "\"" 1)))
                                    `"`))
     #
     :escape (sequence "\\"
                       (choice (set `"'0?\abefnrtvz`)
                               (sequence "x" (2 :h))
                               (sequence "u" (4 :h))
                               (sequence "U" (6 :h))
                               (error (constant "bad escape"))))
     #
     :string ,(l/atom-node :string
                         '(sequence `"`
                                    (any (choice :escape
                                                 (if-not "\"" 1)))
                                    `"`))
     #
     :long-string ,(l/atom-node :long-string
                              :long-bytes)
     #
     :long-bytes {:main (drop (sequence :open
                                        (any (if-not :close 1))
                                        :close))
                  :open (capture :delim :n)
                  :delim (some "`")
                  :close (cmt (sequence (not (look -1 "`"))
                                        (backref :n)
                                        (capture (backmatch :n)))
                              ,=)}
     #
     :long-buffer ,(l/atom-node :long-buffer
                              '(sequence "@" :long-bytes))
     #
     :keyword ,(l/atom-node :keyword
                          '(sequence ":"
                                     (any :name-char)))
     #
     :symbol ,(l/atom-node :symbol
                         '(some :name-char))
     })

(comment

  (get (peg/match l/loc-grammar " ") 2)
  # =>
  '(:whitespace @{:bc 1 :bl 1 :ec 2 :el 1} " ")

  (get (peg/match l/loc-grammar "true?") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 6 :el 1} "true?")

  (get (peg/match l/loc-grammar "nil?") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 5 :el 1} "nil?")

  (get (peg/match l/loc-grammar "false?") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 7 :el 1} "false?")

  (get (peg/match l/loc-grammar "# hi there") 2)
  # =>
  '(:comment @{:bc 1 :bl 1 :ec 11 :el 1} "# hi there")

  (get (peg/match l/loc-grammar "1_000_000") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 10 :el 1} "1_000_000")

  (get (peg/match l/loc-grammar "8.3") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 4 :el 1} "8.3")

  (get (peg/match l/loc-grammar "1e2") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 4 :el 1} "1e2")

  (get (peg/match l/loc-grammar "0xfe") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 5 :el 1} "0xfe")

  (get (peg/match l/loc-grammar "2r01") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 5 :el 1} "2r01")

  (get (peg/match l/loc-grammar "3r101&01") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 9 :el 1} "3r101&01")

  (get (peg/match l/loc-grammar "2:u") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 4 :el 1} "2:u")

  (get (peg/match l/loc-grammar "-8:s") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 5 :el 1} "-8:s")

  (get (peg/match l/loc-grammar "1e2:n") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 6 :el 1} "1e2:n")

  (get (peg/match l/loc-grammar "printf") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 7 :el 1} "printf")

  (get (peg/match l/loc-grammar ":smile") 2)
  # =>
  '(:keyword @{:bc 1 :bl 1 :ec 7 :el 1} ":smile")

  (get (peg/match l/loc-grammar `"fun"`) 2)
  # =>
  '(:string @{:bc 1 :bl 1 :ec 6 :el 1} "\"fun\"")

  (get (peg/match l/loc-grammar "``long-fun``") 2)
  # =>
  '(:long-string @{:bc 1 :bl 1 :ec 13 :el 1} "``long-fun``")

  (get (peg/match l/loc-grammar "@``long-buffer-fun``") 2)
  # =>
  '(:long-buffer @{:bc 1 :bl 1 :ec 21 :el 1} "@``long-buffer-fun``")

  (get (peg/match l/loc-grammar `@"a buffer"`) 2)
  # =>
  '(:buffer @{:bc 1 :bl 1 :ec 12 :el 1} "@\"a buffer\"")

  (get (peg/match l/loc-grammar "@[8]") 2)
  # =>
  '(:bracket-array @{:bc 1 :bl 1
                     :ec 5 :el 1}
                   (:number @{:bc 3 :bl 1
                              :ec 4 :el 1} "8"))

  (get (peg/match l/loc-grammar "@{:a 1}") 2)
  # =>
  '(:table @{:bc 1 :bl 1
             :ec 8 :el 1}
           (:keyword @{:bc 3 :bl 1
                       :ec 5 :el 1} ":a")
           (:whitespace @{:bc 5 :bl 1
                          :ec 6 :el 1} " ")
           (:number @{:bc 6 :bl 1
                      :ec 7 :el 1} "1"))

  (get (peg/match l/loc-grammar "~x") 2)
  # =>
  '(:quasiquote @{:bc 1 :bl 1
                  :ec 3 :el 1}
                (:symbol @{:bc 2 :bl 1
                           :ec 3 :el 1} "x"))

  (get (peg/match l/loc-grammar "' '[:a :b]") 2)
  # =>
  '(:quote @{:bc 1 :bl 1
             :ec 11 :el 1}
           (:whitespace @{:bc 2 :bl 1
                          :ec 3 :el 1} " ")
           (:quote @{:bc 3 :bl 1
                     :ec 11 :el 1}
                   (:bracket-tuple @{:bc 4 :bl 1
                                     :ec 11 :el 1}
                                   (:keyword @{:bc 5 :bl 1
                                               :ec 7 :el 1} ":a")
                                   (:whitespace @{:bc 7 :bl 1
                                                  :ec 8 :el 1} " ")
                                   (:keyword @{:bc 8 :bl 1
                                               :ec 10 :el 1} ":b"))))

  )

(def l/loc-top-level-ast
  (put (table ;(kvs l/loc-grammar))
       :main ~(sequence (line) (column)
                        :input
                        (line) (column))))

(defn l/par
  [src &opt start single]
  (default start 0)
  (if single
    (if-let [[bl bc tree el ec]
             (peg/match l/loc-top-level-ast src start)]
      @[:code (l/make-attrs bl bc el ec) tree]
      @[:code])
    (if-let [captures (peg/match l/loc-grammar src start)]
      (let [[bl bc] (slice captures 0 2)
            [el ec] (slice captures -3)
            trees (array/slice captures 2 -3)]
        (array/insert trees 0
                      :code (l/make-attrs bl bc el ec)))
      @[:code])))

# XXX: backward compatibility
(def l/ast l/par)

(comment

  (l/par "(+ 1 1)")
  # =>
  '@[:code @{:bc 1 :bl 1
             :ec 8 :el 1}
     (:tuple @{:bc 1 :bl 1
               :ec 8 :el 1}
             (:symbol @{:bc 2 :bl 1
                        :ec 3 :el 1} "+")
             (:whitespace @{:bc 3 :bl 1
                            :ec 4 :el 1} " ")
             (:number @{:bc 4 :bl 1
                        :ec 5 :el 1} "1")
             (:whitespace @{:bc 5 :bl 1
                            :ec 6 :el 1} " ")
             (:number @{:bc 6 :bl 1
                        :ec 7 :el 1} "1"))]

  )

(defn l/gen*
  [an-ast buf]
  (case (first an-ast)
    :code
    (each elt (drop 2 an-ast)
      (l/gen* elt buf))
    #
    :buffer
    (buffer/push-string buf (in an-ast 2))
    :comment
    (buffer/push-string buf (in an-ast 2))
    :constant
    (buffer/push-string buf (in an-ast 2))
    :keyword
    (buffer/push-string buf (in an-ast 2))
    :long-buffer
    (buffer/push-string buf (in an-ast 2))
    :long-string
    (buffer/push-string buf (in an-ast 2))
    :number
    (buffer/push-string buf (in an-ast 2))
    :string
    (buffer/push-string buf (in an-ast 2))
    :symbol
    (buffer/push-string buf (in an-ast 2))
    :whitespace
    (buffer/push-string buf (in an-ast 2))
    #
    :array
    (do
      (buffer/push-string buf "@(")
      (each elt (drop 2 an-ast)
        (l/gen* elt buf))
      (buffer/push-string buf ")"))
    :bracket-array
    (do
      (buffer/push-string buf "@[")
      (each elt (drop 2 an-ast)
        (l/gen* elt buf))
      (buffer/push-string buf "]"))
    :bracket-tuple
    (do
      (buffer/push-string buf "[")
      (each elt (drop 2 an-ast)
        (l/gen* elt buf))
      (buffer/push-string buf "]"))
    :tuple
    (do
      (buffer/push-string buf "(")
      (each elt (drop 2 an-ast)
        (l/gen* elt buf))
      (buffer/push-string buf ")"))
    :struct
    (do
      (buffer/push-string buf "{")
      (each elt (drop 2 an-ast)
        (l/gen* elt buf))
      (buffer/push-string buf "}"))
    :table
    (do
      (buffer/push-string buf "@{")
      (each elt (drop 2 an-ast)
        (l/gen* elt buf))
      (buffer/push-string buf "}"))
    #
    :fn
    (do
      (buffer/push-string buf "|")
      (each elt (drop 2 an-ast)
        (l/gen* elt buf)))
    :quasiquote
    (do
      (buffer/push-string buf "~")
      (each elt (drop 2 an-ast)
        (l/gen* elt buf)))
    :quote
    (do
      (buffer/push-string buf "'")
      (each elt (drop 2 an-ast)
        (l/gen* elt buf)))
    :splice
    (do
      (buffer/push-string buf ";")
      (each elt (drop 2 an-ast)
        (l/gen* elt buf)))
    :unquote
    (do
      (buffer/push-string buf ",")
      (each elt (drop 2 an-ast)
        (l/gen* elt buf)))
    ))

(defn l/gen
  [an-ast]
  (let [buf @""]
    (l/gen* an-ast buf)
    # XXX: leave as buffer?
    (string buf)))

# XXX: backward compatibility
(def l/code l/gen)

(comment

  (l/gen
    [:code])
  # =>
  ""

  (l/gen
    '(:whitespace @{:bc 1 :bl 1
                    :ec 2 :el 1} " "))
  # =>
  " "

  (l/gen
    '(:buffer @{:bc 1 :bl 1
                :ec 12 :el 1} "@\"a buffer\""))
  # =>
  `@"a buffer"`

  (l/gen
    '@[:code @{:bc 1 :bl 1
               :ec 8 :el 1}
       (:tuple @{:bc 1 :bl 1
                 :ec 8 :el 1}
               (:symbol @{:bc 2 :bl 1
                          :ec 3 :el 1} "+")
               (:whitespace @{:bc 3 :bl 1
                              :ec 4 :el 1} " ")
               (:number @{:bc 4 :bl 1
                          :ec 5 :el 1} "1")
               (:whitespace @{:bc 5 :bl 1
                              :ec 6 :el 1} " ")
               (:number @{:bc 6 :bl 1
                          :ec 7 :el 1} "1"))])
  # =>
  "(+ 1 1)"

  )

(comment

  (def src "{:x  :y \n :z  [:a  :b    :c]}")

  (l/gen (l/par src))
  # =>
  src

  )

(comment

  (comment

    (let [src (slurp (string (os/getenv "HOME")
                             "/src/janet/src/boot/boot.janet"))]
      (= (string src)
         (l/gen (l/par src))))

    )

  )

(comment import ./jipper :prefix "")
#! /usr/bin/env janet

(comment import ./helpers :prefix "")
# based on code by corasaurus-hex

# `slice` doesn't necessarily preserve the input type

# XXX: differs from clojure's behavior
#      e.g. (butlast [:a]) would yield nil(?!) in clojure
(defn j/h/butlast
  [indexed]
  (if (empty? indexed)
    nil
    (if (tuple? indexed)
      (tuple/slice indexed 0 -2)
      (array/slice indexed 0 -2))))

(comment

  (j/h/butlast @[:a :b :c])
  # =>
  @[:a :b]

  (j/h/butlast [:a])
  # =>
  []

  )

(defn j/h/rest
  [indexed]
  (if (empty? indexed)
    nil
    (if (tuple? indexed)
      (tuple/slice indexed 1 -1)
      (array/slice indexed 1 -1))))

(comment

  (j/h/rest [:a :b :c])
  # =>
  [:b :c]

  (j/h/rest @[:a])
  # =>
  @[]

  )

# XXX: can pass in array - will get back tuple
(defn j/h/tuple-push
  [tup x & xs]
  (if tup
    [;tup x ;xs]
    [x ;xs]))

(comment

  (j/h/tuple-push [:a :b] :c)
  # =>
  [:a :b :c]

  (j/h/tuple-push nil :a)
  # =>
  [:a]

  (j/h/tuple-push @[] :a)
  # =>
  [:a]

  )

(defn j/h/to-entries
  [val]
  (if (dictionary? val)
    (pairs val)
    val))

(comment

  (sort (j/h/to-entries {:a 1 :b 2}))
  # =>
  @[[:a 1] [:b 2]]

  (j/h/to-entries {})
  # =>
  @[]

  (j/h/to-entries @{:a 1})
  # =>
  @[[:a 1]]

  # XXX: leaving non-dictionaries alone and passing through...
  #      is this desirable over erroring?
  (j/h/to-entries [:a :b :c])
  # =>
  [:a :b :c]

  )

# XXX: when xs is empty, "all" becomes nil
(defn j/h/first-rest-maybe-all
  [xs]
  (if (or (nil? xs) (empty? xs))
    [nil nil nil]
    [(first xs) (j/h/rest xs) xs]))

(comment

  (j/h/first-rest-maybe-all [:a :b])
  # =>
  [:a [:b] [:a :b]]

  (j/h/first-rest-maybe-all @[:a])
  # =>
  [:a @[] @[:a]]

  (j/h/first-rest-maybe-all [])
  # =>
  [nil nil nil]

  # XXX: is this what we want?
  (j/h/first-rest-maybe-all nil)
  # =>
  [nil nil nil]

  )


(comment import ./location :prefix "")
# bl - begin line
# bc - begin column
# el - end line
# ec - end column
(defn j/l/make-attrs
  [& items]
  (zipcoll [:bl :bc :el :ec]
           items))

(defn j/l/atom-node
  [node-type peg-form]
  ~(cmt (capture (sequence (line) (column)
                           ,peg-form
                           (line) (column)))
        ,|[node-type (j/l/make-attrs ;(slice $& 0 -2)) (last $&)]))

(defn j/l/reader-macro-node
  [node-type sigil]
  ~(cmt (capture (sequence (line) (column)
                           ,sigil
                           (any :non-form)
                           :form
                           (line) (column)))
        ,|[node-type (j/l/make-attrs ;(slice $& 0 2) ;(slice $& -4 -2))
           ;(slice $& 2 -4)]))

(defn j/l/collection-node
  [node-type open-delim close-delim]
  ~(cmt
     (capture
       (sequence
         (line) (column)
         ,open-delim
         (any :input)
         (choice ,close-delim
                 (error
                   (replace (sequence (line) (column))
                            ,|(string/format
                                "line: %p column: %p missing %p for %p"
                                $0 $1 close-delim node-type))))
         (line) (column)))
     ,|[node-type (j/l/make-attrs ;(slice $& 0 2) ;(slice $& -4 -2))
        ;(slice $& 2 -4)]))

(def j/l/loc-grammar
  ~@{:main (sequence (line) (column)
                     (some :input)
                     (line) (column))
     #
     :input (choice :non-form
                    :form)
     #
     :non-form (choice :whitespace
                       :comment)
     #
     :whitespace ,(j/l/atom-node :whitespace
                             '(choice (some (set " \0\f\t\v"))
                                      (choice "\r\n"
                                              "\r"
                                              "\n")))
     # :whitespace
     # (cmt (capture (sequence (line) (column)
     #                         (choice (some (set " \0\f\t\v"))
     #                                 (choice "\r\n"
     #                                         "\r"
     #                                         "\n"))
     #                         (line) (column)))
     #      ,|[:whitespace (make-attrs ;(slice $& 0 -2)) (last $&)])
     #
     :comment ,(j/l/atom-node :comment
                          '(sequence "#"
                                     (any (if-not (set "\r\n") 1))))
     #
     :form (choice # reader macros
                   :fn
                   :quasiquote
                   :quote
                   :splice
                   :unquote
                   # collections
                   :array
                   :bracket-array
                   :tuple
                   :bracket-tuple
                   :table
                   :struct
                   # atoms
                   :number
                   :constant
                   :buffer
                   :string
                   :long-buffer
                   :long-string
                   :keyword
                   :symbol)
     #
     :fn ,(j/l/reader-macro-node :fn "|")
     # :fn (cmt (capture (sequence (line) (column)
     #                             "|"
     #                             (any :non-form)
     #                             :form
     #                             (line) (column)))
     #          ,|[:fn (make-attrs ;(slice $& 0 2) ;(slice $& -4 -2))
     #             ;(slice $& 2 -4)])
     #
     :quasiquote ,(j/l/reader-macro-node :quasiquote "~")
     #
     :quote ,(j/l/reader-macro-node :quote "'")
     #
     :splice ,(j/l/reader-macro-node :splice ";")
     #
     :unquote ,(j/l/reader-macro-node :unquote ",")
     #
     :array ,(j/l/collection-node :array "@(" ")")
     # :array
     # (cmt
     #   (capture
     #     (sequence
     #       (line) (column)
     #       "@("
     #       (any :input)
     #       (choice ")"
     #               (error
     #                 (replace (sequence (line) (column))
     #                          ,|(string/format
     #                              "line: %p column: %p missing %p for %p"
     #                              $0 $1 ")" :array))))
     #       (line) (column)))
     #   ,|[:array (make-attrs ;(slice $& 0 2) ;(slice $& -4 -2))
     #      ;(slice $& 2 -4)])
     #
     :tuple ,(j/l/collection-node :tuple "(" ")")
     #
     :bracket-array ,(j/l/collection-node :bracket-array "@[" "]")
     #
     :bracket-tuple ,(j/l/collection-node :bracket-tuple "[" "]")
     #
     :table ,(j/l/collection-node :table "@{" "}")
     #
     :struct ,(j/l/collection-node :struct "{" "}")
     #
     :number ,(j/l/atom-node :number
                         ~(drop (sequence (cmt (capture (some :num-char))
                                               ,scan-number)
                                          (opt (sequence ":" (range "AZ" "az"))))))
     #
     :num-char (choice (range "09" "AZ" "az")
                       (set "&+-._"))
     #
     :constant ,(j/l/atom-node :constant
                           '(sequence (choice "false" "nil" "true")
                                      (not :name-char)))
     #
     :name-char (choice (range "09" "AZ" "az" "\x80\xFF")
                        (set "!$%&*+-./:<?=>@^_"))
     #
     :buffer ,(j/l/atom-node :buffer
                         '(sequence `@"`
                                    (any (choice :escape
                                                 (if-not "\"" 1)))
                                    `"`))
     #
     :escape (sequence "\\"
                       (choice (set `"'0?\abefnrtvz`)
                               (sequence "x" (2 :h))
                               (sequence "u" (4 :h))
                               (sequence "U" (6 :h))
                               (error (constant "bad escape"))))
     #
     :string ,(j/l/atom-node :string
                         '(sequence `"`
                                    (any (choice :escape
                                                 (if-not "\"" 1)))
                                    `"`))
     #
     :long-string ,(j/l/atom-node :long-string
                              :long-bytes)
     #
     :long-bytes {:main (drop (sequence :open
                                        (any (if-not :close 1))
                                        :close))
                  :open (capture :delim :n)
                  :delim (some "`")
                  :close (cmt (sequence (not (look -1 "`"))
                                        (backref :n)
                                        (capture (backmatch :n)))
                              ,=)}
     #
     :long-buffer ,(j/l/atom-node :long-buffer
                              '(sequence "@" :long-bytes))
     #
     :keyword ,(j/l/atom-node :keyword
                          '(sequence ":"
                                     (any :name-char)))
     #
     :symbol ,(j/l/atom-node :symbol
                         '(some :name-char))
     })

(comment

  (get (peg/match j/l/loc-grammar " ") 2)
  # =>
  '(:whitespace @{:bc 1 :bl 1 :ec 2 :el 1} " ")

  (get (peg/match j/l/loc-grammar "true?") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 6 :el 1} "true?")

  (get (peg/match j/l/loc-grammar "nil?") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 5 :el 1} "nil?")

  (get (peg/match j/l/loc-grammar "false?") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 7 :el 1} "false?")

  (get (peg/match j/l/loc-grammar "# hi there") 2)
  # =>
  '(:comment @{:bc 1 :bl 1 :ec 11 :el 1} "# hi there")

  (get (peg/match j/l/loc-grammar "1_000_000") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 10 :el 1} "1_000_000")

  (get (peg/match j/l/loc-grammar "8.3") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 4 :el 1} "8.3")

  (get (peg/match j/l/loc-grammar "1e2") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 4 :el 1} "1e2")

  (get (peg/match j/l/loc-grammar "0xfe") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 5 :el 1} "0xfe")

  (get (peg/match j/l/loc-grammar "2r01") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 5 :el 1} "2r01")

  (get (peg/match j/l/loc-grammar "3r101&01") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 9 :el 1} "3r101&01")

  (get (peg/match j/l/loc-grammar "2:u") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 4 :el 1} "2:u")

  (get (peg/match j/l/loc-grammar "-8:s") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 5 :el 1} "-8:s")

  (get (peg/match j/l/loc-grammar "1e2:n") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 6 :el 1} "1e2:n")

  (get (peg/match j/l/loc-grammar "printf") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 7 :el 1} "printf")

  (get (peg/match j/l/loc-grammar ":smile") 2)
  # =>
  '(:keyword @{:bc 1 :bl 1 :ec 7 :el 1} ":smile")

  (get (peg/match j/l/loc-grammar `"fun"`) 2)
  # =>
  '(:string @{:bc 1 :bl 1 :ec 6 :el 1} "\"fun\"")

  (get (peg/match j/l/loc-grammar "``long-fun``") 2)
  # =>
  '(:long-string @{:bc 1 :bl 1 :ec 13 :el 1} "``long-fun``")

  (get (peg/match j/l/loc-grammar "@``long-buffer-fun``") 2)
  # =>
  '(:long-buffer @{:bc 1 :bl 1 :ec 21 :el 1} "@``long-buffer-fun``")

  (get (peg/match j/l/loc-grammar `@"a buffer"`) 2)
  # =>
  '(:buffer @{:bc 1 :bl 1 :ec 12 :el 1} "@\"a buffer\"")

  (get (peg/match j/l/loc-grammar "@[8]") 2)
  # =>
  '(:bracket-array @{:bc 1 :bl 1
                     :ec 5 :el 1}
                   (:number @{:bc 3 :bl 1
                              :ec 4 :el 1} "8"))

  (get (peg/match j/l/loc-grammar "@{:a 1}") 2)
  # =>
  '(:table @{:bc 1 :bl 1
             :ec 8 :el 1}
           (:keyword @{:bc 3 :bl 1
                       :ec 5 :el 1} ":a")
           (:whitespace @{:bc 5 :bl 1
                          :ec 6 :el 1} " ")
           (:number @{:bc 6 :bl 1
                      :ec 7 :el 1} "1"))

  (get (peg/match j/l/loc-grammar "~x") 2)
  # =>
  '(:quasiquote @{:bc 1 :bl 1
                  :ec 3 :el 1}
                (:symbol @{:bc 2 :bl 1
                           :ec 3 :el 1} "x"))

  (get (peg/match j/l/loc-grammar "' '[:a :b]") 2)
  # =>
  '(:quote @{:bc 1 :bl 1
             :ec 11 :el 1}
           (:whitespace @{:bc 2 :bl 1
                          :ec 3 :el 1} " ")
           (:quote @{:bc 3 :bl 1
                     :ec 11 :el 1}
                   (:bracket-tuple @{:bc 4 :bl 1
                                     :ec 11 :el 1}
                                   (:keyword @{:bc 5 :bl 1
                                               :ec 7 :el 1} ":a")
                                   (:whitespace @{:bc 7 :bl 1
                                                  :ec 8 :el 1} " ")
                                   (:keyword @{:bc 8 :bl 1
                                               :ec 10 :el 1} ":b"))))

  )

(def j/l/loc-top-level-ast
  (put (table ;(kvs j/l/loc-grammar))
       :main ~(sequence (line) (column)
                        :input
                        (line) (column))))

(defn j/l/par
  [src &opt start single]
  (default start 0)
  (if single
    (if-let [[bl bc tree el ec]
             (peg/match j/l/loc-top-level-ast src start)]
      @[:code (j/l/make-attrs bl bc el ec) tree]
      @[:code])
    (if-let [captures (peg/match j/l/loc-grammar src start)]
      (let [[bl bc] (slice captures 0 2)
            [el ec] (slice captures -3)
            trees (array/slice captures 2 -3)]
        (array/insert trees 0
                      :code (j/l/make-attrs bl bc el ec)))
      @[:code])))

# XXX: backward compatibility
(def j/l/ast j/l/par)

(comment

  (j/l/par "(+ 1 1)")
  # =>
  '@[:code @{:bc 1 :bl 1
             :ec 8 :el 1}
     (:tuple @{:bc 1 :bl 1
               :ec 8 :el 1}
             (:symbol @{:bc 2 :bl 1
                        :ec 3 :el 1} "+")
             (:whitespace @{:bc 3 :bl 1
                            :ec 4 :el 1} " ")
             (:number @{:bc 4 :bl 1
                        :ec 5 :el 1} "1")
             (:whitespace @{:bc 5 :bl 1
                            :ec 6 :el 1} " ")
             (:number @{:bc 6 :bl 1
                        :ec 7 :el 1} "1"))]

  )

(defn j/l/gen*
  [an-ast buf]
  (case (first an-ast)
    :code
    (each elt (drop 2 an-ast)
      (j/l/gen* elt buf))
    #
    :buffer
    (buffer/push-string buf (in an-ast 2))
    :comment
    (buffer/push-string buf (in an-ast 2))
    :constant
    (buffer/push-string buf (in an-ast 2))
    :keyword
    (buffer/push-string buf (in an-ast 2))
    :long-buffer
    (buffer/push-string buf (in an-ast 2))
    :long-string
    (buffer/push-string buf (in an-ast 2))
    :number
    (buffer/push-string buf (in an-ast 2))
    :string
    (buffer/push-string buf (in an-ast 2))
    :symbol
    (buffer/push-string buf (in an-ast 2))
    :whitespace
    (buffer/push-string buf (in an-ast 2))
    #
    :array
    (do
      (buffer/push-string buf "@(")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf))
      (buffer/push-string buf ")"))
    :bracket-array
    (do
      (buffer/push-string buf "@[")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf))
      (buffer/push-string buf "]"))
    :bracket-tuple
    (do
      (buffer/push-string buf "[")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf))
      (buffer/push-string buf "]"))
    :tuple
    (do
      (buffer/push-string buf "(")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf))
      (buffer/push-string buf ")"))
    :struct
    (do
      (buffer/push-string buf "{")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf))
      (buffer/push-string buf "}"))
    :table
    (do
      (buffer/push-string buf "@{")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf))
      (buffer/push-string buf "}"))
    #
    :fn
    (do
      (buffer/push-string buf "|")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf)))
    :quasiquote
    (do
      (buffer/push-string buf "~")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf)))
    :quote
    (do
      (buffer/push-string buf "'")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf)))
    :splice
    (do
      (buffer/push-string buf ";")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf)))
    :unquote
    (do
      (buffer/push-string buf ",")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf)))
    ))

(defn j/l/gen
  [an-ast]
  (let [buf @""]
    (j/l/gen* an-ast buf)
    # XXX: leave as buffer?
    (string buf)))

# XXX: backward compatibility
(def j/l/code j/l/gen)

(comment

  (j/l/gen
    [:code])
  # =>
  ""

  (j/l/gen
    '(:whitespace @{:bc 1 :bl 1
                    :ec 2 :el 1} " "))
  # =>
  " "

  (j/l/gen
    '(:buffer @{:bc 1 :bl 1
                :ec 12 :el 1} "@\"a buffer\""))
  # =>
  `@"a buffer"`

  (j/l/gen
    '@[:code @{:bc 1 :bl 1
               :ec 8 :el 1}
       (:tuple @{:bc 1 :bl 1
                 :ec 8 :el 1}
               (:symbol @{:bc 2 :bl 1
                          :ec 3 :el 1} "+")
               (:whitespace @{:bc 3 :bl 1
                              :ec 4 :el 1} " ")
               (:number @{:bc 4 :bl 1
                          :ec 5 :el 1} "1")
               (:whitespace @{:bc 5 :bl 1
                              :ec 6 :el 1} " ")
               (:number @{:bc 6 :bl 1
                          :ec 7 :el 1} "1"))])
  # =>
  "(+ 1 1)"

  )

(comment

  (def src "{:x  :y \n :z  [:a  :b    :c]}")

  (j/l/gen (j/l/par src))
  # =>
  src

  )

(comment

  (comment

    (let [src (slurp (string (os/getenv "HOME")
                             "/src/janet/src/boot/boot.janet"))]
      (= (string src)
         (j/l/gen (j/l/par src))))

    )

  )


(def j/version "2026-01-15_14-02-34")

# exports
(def j/par j/l/par)
(def j/gen j/l/gen)

########################################################################

(defn j/zipper
  ``
  Returns a new zipper consisting of two elements:

  * `a-root` - the passed in root node.
  * `state` - table of info about node's z-location in the tree with keys:
    * `:ls` - left siblings
    * `:pnodes` - path of nodes from root to current z-location
    * `:pstate` - parent node's state
    * `:rs` - right siblings
    * `:changed?` - indicates whether "editing" has occured

  `state` has a prototype table with four functions:

  * :branch? - fn that tests if a node is a branch (has children)
  * :children - fn that returns the child nodes for the given branch.
  * :make-node - fn that takes a node + children and returns a new branch
    node with the same.
  * :make-state - fn for creating a new state
  ``
  [a-root branch?-fn children-fn make-node-fn]
  #
  (defn make-state_
    [&opt ls_ rs_ pnodes_ pstate_ changed?_]
    (table/setproto @{:ls ls_
                      :pnodes pnodes_
                      :pstate pstate_
                      :rs rs_
                      :changed? changed?_}
                    @{:branch? branch?-fn
                      :children children-fn
                      :make-node make-node-fn
                      :make-state make-state_}))
  #
  [a-root (make-state_)])

(comment

  # XXX

  )

# ds - data structure
(defn j/ds-zip
  ``
  Returns a zipper for nested data structures (tuple/array/table/struct),
  given a root data structure.
  ``
  [ds]
  (j/zipper ds
          |(or (dictionary? $) (indexed? $))
          j/h/to-entries
          (fn [p xs] xs)))

(comment

  (def a-node
    [:x [:y :z]])

  (def [the-node the-state]
    (j/ds-zip a-node))

  the-node
  # =>
  a-node

  # merge is used to "remove" the prototype table of `st`
  (merge {} the-state)
  # =>
  @{}

  )

(defn j/node
  "Returns the node at `zloc`."
  [zloc]
  (get zloc 0))

(comment

  (j/node (j/ds-zip [:a :b [:x :y]]))
  # =>
  [:a :b [:x :y]]

  )

(defn j/state
  "Returns the state for `zloc`."
  [zloc]
  (get zloc 1))

(comment

  # merge is used to "remove" the prototype table of `st`
  (merge {}
         (-> (j/ds-zip [:a [:b [:x :y]]])
             j/state))
  # =>
  @{}

  )

(defn j/branch?
  ``
  Returns true if the node at `zloc` is a branch.
  Returns false otherwise.
  ``
  [zloc]
  (((j/state zloc) :branch?) (j/node zloc)))

(comment

  (j/branch? (j/ds-zip [:a :b [:x :y]]))
  # =>
  true

  )

(defn j/children
  ``
  Returns children for a branch node at `zloc`.
  Otherwise throws an error.
  ``
  [zloc]
  (if (j/branch? zloc)
    (((j/state zloc) :children) (j/node zloc))
    (error "Called `children` on a non-branch zloc")))

(comment

  (j/children (j/ds-zip [:a :b [:x :y]]))
  # =>
  [:a :b [:x :y]]

  )

(defn j/make-state
  ``
  Convenience function for calling the :make-state function for `zloc`.
  ``
  [zloc &opt ls rs pnodes pstate changed?]
  (((j/state zloc) :make-state) ls rs pnodes pstate changed?))

(comment

  # merge is used to "remove" the prototype table of `st`
  (merge {}
         (j/make-state (j/ds-zip [:a :b [:x :y]])))
  # =>
  @{}

  )

(defn j/down
  ``
  Moves down the tree, returning the leftmost child z-location of
  `zloc`, or nil if there are no children.
  ``
  [zloc]
  (when (j/branch? zloc)
    (let [[z-node st] zloc
          [k rest-kids kids]
          (j/h/first-rest-maybe-all (j/children zloc))]
      (when kids
        [k
         (j/make-state zloc
                     []
                     rest-kids
                     (if (not (empty? st))
                       (j/h/tuple-push (get st :pnodes) z-node)
                       [z-node])
                     st
                     (get st :changed?))]))))

(comment

  (j/node (j/down (j/ds-zip [:a :b [:x :y]])))
  # =>
  :a

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/branch?)
  # =>
  false

  (try
    (-> (j/ds-zip [:a])
        j/down
        j/children)
    ([e] e))
  # =>
  "Called `children` on a non-branch zloc"

  (deep=
    #
    (merge {}
           (-> [:a [:b [:x :y]]]
               j/ds-zip
               j/down
               j/state))
    #
    '@{:ls ()
       :pnodes ((:a (:b (:x :y))))
       :pstate @{}
       :rs ((:b (:x :y)))})
  # =>
  true

  )

(defn j/right
  ``
  Returns the z-location of the right sibling of the node
  at `zloc`, or nil if there is no such sibling.
  ``
  [zloc]
  (let [[z-node st] zloc
        {:ls ls :rs rs} st
        [r rest-rs rs] (j/h/first-rest-maybe-all rs)]
    (when (and (not (empty? st)) rs)
      [r
       (j/make-state zloc
                   (j/h/tuple-push ls z-node)
                   rest-rs
                   (get st :pnodes)
                   (get st :pstate)
                   (get st :changed?))])))

(comment

  (-> (j/ds-zip [:a :b])
      j/down
      j/right
      j/node)
  # =>
  :b

  (-> (j/ds-zip [:a])
      j/down
      j/right)
  # =>
  nil

  )

(defn j/make-node
  ``
  Returns a branch node, given `zloc`, `a-node` and `kids`.
  ``
  [zloc a-node kids]
  (((j/state zloc) :make-node) a-node kids))

(comment

  (j/make-node (j/ds-zip [:a :b [:x :y]])
             [:a :b] [:x :y])
  # =>
  [:x :y]

  )

(defn j/up
  ``
  Moves up the tree, returning the parent z-location of `zloc`,
  or nil if at the root z-location.
  ``
  [zloc]
  (let [[z-node st] zloc
        {:ls ls
         :pnodes pnodes
         :pstate pstate
         :rs rs
         :changed? changed?} st]
    (when pnodes
      (let [pnode (last pnodes)]
        (if changed?
          [(j/make-node zloc pnode [;ls z-node ;rs])
           (j/make-state zloc
                       (get pstate :ls)
                       (get pstate :rs)
                       (get pstate :pnodes)
                       (get pstate :pstate)
                       true)]
          [pnode pstate])))))

(comment

  (def m-zip
    (j/ds-zip [:a :b [:x :y]]))

  (deep=
    (-> m-zip
        j/down
        j/up)
    m-zip)
  # =>
  true

  (deep=
    (-> m-zip
        j/down
        j/right
        j/right
        j/down
        j/up
        j/up)
    m-zip)
  # =>
  true

  )

# XXX: used by `root` and `df-next`
(defn j/end?
  "Returns true if `zloc` represents the end of a depth-first walk."
  [zloc]
  (= :end (j/state zloc)))

(defn j/root
  ``
  Moves all the way up the tree for `zloc` and returns the node at
  the root z-location.
  ``
  [zloc]
  (if (j/end? zloc)
    (j/node zloc)
    (if-let [p (j/up zloc)]
      (j/root p)
      (j/node zloc))))

(comment

  (def a-zip
    (j/ds-zip [:a :b [:x :y]]))

  (j/node a-zip)
  # =>
  (-> a-zip
      j/down
      j/right
      j/right
      j/down
      j/root)

  )

(defn j/df-next
  ``
  Moves to the next z-location, depth-first.  When the end is
  reached, returns a special z-location detectable via `end?`.
  Does not move if already at the end.
  ``
  [zloc]
  #
  (defn recur
    [a-loc]
    (if (j/up a-loc)
      (or (j/right (j/up a-loc))
          (recur (j/up a-loc)))
      [(j/node a-loc) :end]))
  #
  (if (j/end? zloc)
    zloc
    (or (and (j/branch? zloc) (j/down zloc))
        (j/right zloc)
        (recur zloc))))

(comment

  (def a-zip
    (j/ds-zip [:a :b [:x]]))

  (j/node (j/df-next a-zip))
  # =>
  :a

  (-> a-zip
      j/df-next
      j/df-next
      j/node)
  # =>
  :b

  (-> a-zip
      j/df-next
      j/df-next
      j/df-next
      j/df-next
      j/df-next
      j/end?)
  # =>
  true

  )

(defn j/replace
  "Replaces existing node at `zloc` with `a-node`, without moving."
  [zloc a-node]
  (let [[_ st] zloc]
    [a-node
     (j/make-state zloc
                 (get st :ls)
                 (get st :rs)
                 (get st :pnodes)
                 (get st :pstate)
                 true)]))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      (j/replace :w)
      j/root)
  # =>
  [:w :b [:x :y]]

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/right
      j/right
      j/down
      (j/replace :w)
      j/root)
  # =>
  [:a :b [:w :y]]

  )

(defn j/edit
  ``
  Replaces the node at `zloc` with the value of `(f node args)`,
  where `node` is the node associated with `zloc`.
  ``
  [zloc f & args]
  (j/replace zloc
           (apply f (j/node zloc) args)))

(comment

  (-> (j/ds-zip [1 2 [8 9]])
      j/down
      (j/edit inc)
      j/root)
  # =>
  [2 2 [8 9]]

  (-> (j/ds-zip [1 2 [8 9]])
      j/down
      (j/edit inc)
      j/right
      (j/edit inc)
      j/right
      j/down
      (j/edit dec)
      j/right
      (j/edit dec)
      j/root)
  # =>
  [2 3 [7 8]]

  )

(defn j/insert-child
  ``
  Inserts `child` as the leftmost child of the node at `zloc`,
  without moving.
  ``
  [zloc child]
  (j/replace zloc
           (j/make-node zloc
                      (j/node zloc)
                      [child ;(j/children zloc)])))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      (j/insert-child :c)
      j/root)
  # =>
  [:c :a :b [:x :y]]

  )

(defn j/append-child
  ``
  Appends `child` as the rightmost child of the node at `zloc`,
  without moving.
  ``
  [zloc child]
  (j/replace zloc
           (j/make-node zloc
                      (j/node zloc)
                      [;(j/children zloc) child])))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      (j/append-child :c)
      j/root)
  # =>
  [:a :b [:x :y] :c]

  )

(defn j/rightmost
  ``
  Returns the z-location of the rightmost sibling of the node at
  `zloc`, or the current node's z-location if there are none to the
  right.
  ``
  [zloc]
  (let [[z-node st] zloc
        {:ls ls :rs rs} st]
    (if (and (not (empty? st))
             (indexed? rs)
             (not (empty? rs)))
      [(last rs)
       (j/make-state zloc
                   (j/h/tuple-push ls z-node ;(j/h/butlast rs))
                   []
                   (get st :pnodes)
                   (get st :pstate)
                   (get st :changed?))]
      zloc)))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/rightmost
      j/node)
  # =>
  [:x :y]

  )

(defn j/remove
  ``
  Removes the node at `zloc`, returning the z-location that would have
  preceded it in a depth-first walk.
  Throws an error if called at the root z-location.
  ``
  [zloc]
  (let [[z-node st] zloc
        {:ls ls
         :pnodes pnodes
         :pstate pstate
         :rs rs} st]
    #
    (defn recur
      [a-zloc]
      (if-let [child (and (j/branch? a-zloc) (j/down a-zloc))]
        (recur (j/rightmost child))
        a-zloc))
    #
    (if (not (empty? st))
      (if (pos? (length ls))
        (recur [(last ls)
                (j/make-state zloc
                            (j/h/butlast ls)
                            rs
                            pnodes
                            pstate
                            true)])
        [(j/make-node zloc (last pnodes) rs)
         (j/make-state zloc
                     (get pstate :ls)
                     (get pstate :rs)
                     (get pstate :pnodes)
                     (get pstate :pstate)
                     true)])
      (error "Called `remove` at root"))))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/right
      j/remove
      j/node)
  # =>
  :a

  (try
    (j/remove (j/ds-zip [:a :b [:x :y]]))
    ([e] e))
  # =>
  "Called `remove` at root"

  )

(defn j/left
  ``
  Returns the z-location of the left sibling of the node
  at `zloc`, or nil if there is no such sibling.
  ``
  [zloc]
  (let [[z-node st] zloc
        {:ls ls :rs rs} st]
    (when (and (not (empty? st))
               (indexed? ls)
               (not (empty? ls)))
      [(last ls)
       (j/make-state zloc
                   (j/h/butlast ls)
                   [z-node ;rs]
                   (get st :pnodes)
                   (get st :pstate)
                   (get st :changed?))])))

(comment

  (-> (j/ds-zip [:a :b :c])
      j/down
      j/right
      j/right
      j/left
      j/node)
  # =>
  :b

  (-> (j/ds-zip [:a])
      j/down
      j/left)
  # =>
  nil

  )

(defn j/df-prev
  ``
  Moves to the previous z-location, depth-first.
  If already at the root, returns nil.
  ``
  [zloc]
  #
  (defn recur
    [a-zloc]
    (if-let [child (and (j/branch? a-zloc)
                        (j/down a-zloc))]
      (recur (j/rightmost child))
      a-zloc))
  #
  (if-let [left-loc (j/left zloc)]
    (recur left-loc)
    (j/up zloc)))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/right
      j/df-prev
      j/node)
  # =>
  :a

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/right
      j/right
      j/down
      j/df-prev
      j/node)
  # =>
  [:x :y]

  )

(defn j/insert-right
  ``
  Inserts `a-node` as the right sibling of the node at `zloc`,
  without moving.
  ``
  [zloc a-node]
  (let [[z-node st] zloc
        {:ls ls :rs rs} st]
    (if (not (empty? st))
      [z-node
       (j/make-state zloc
                   ls
                   [a-node ;rs]
                   (get st :pnodes)
                   (get st :pstate)
                   true)]
      (error "Called `insert-right` at root"))))

(comment

  (def a-zip
    (j/ds-zip [:a :b [:x :y]]))

  (-> a-zip
      j/down
      (j/insert-right :z)
      j/root)
  # =>
  [:a :z :b [:x :y]]

  (try
    (j/insert-right a-zip :e)
    ([e] e))
  # =>
  "Called `insert-right` at root"

  )

(defn j/insert-left
  ``
  Inserts `a-node` as the left sibling of the node at `zloc`,
  without moving.
  ``
  [zloc a-node]
  (let [[z-node st] zloc
        {:ls ls :rs rs} st]
    (if (not (empty? st))
      [z-node
       (j/make-state zloc
                   (j/h/tuple-push ls a-node)
                   rs
                   (get st :pnodes)
                   (get st :pstate)
                   true)]
      (error "Called `insert-left` at root"))))

(comment

  (def a-zip
    (j/ds-zip [:a :b [:x :y]]))

  (-> a-zip
      j/down
      (j/insert-left :z)
      j/root)
  # =>
  [:z :a :b [:x :y]]

  (try
    (j/insert-left a-zip :e)
    ([e] e))
  # =>
  "Called `insert-left` at root"

  )

(defn j/rights
  "Returns siblings to the right of `zloc`."
  [zloc]
  (when-let [st (j/state zloc)]
    (get st :rs)))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/rights)
  # =>
  [:b [:x :y]]

  )

(defn j/lefts
  "Returns siblings to the left of `zloc`."
  [zloc]
  (if-let [st (j/state zloc)
           ls (get st :ls)]
    ls
    []))

(comment

  (-> (j/ds-zip [:a :b])
      j/down
      j/lefts)
  # =>
  []

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/right
      j/right
      j/lefts)
  # =>
  [:a :b]

  )

(defn j/leftmost
  ``
  Returns the z-location of the leftmost sibling of the node at `zloc`,
  or the current node's z-location if there are no siblings to the left.
  ``
  [zloc]
  (let [[z-node st] zloc
        {:ls ls :rs rs} st]
    (if (and (not (empty? st))
             (indexed? ls)
             (not (empty? ls)))
      [(first ls)
       (j/make-state zloc
                   []
                   [;(j/h/rest ls) z-node ;rs]
                   (get st :pnodes)
                   (get st :pstate)
                   (get st :changed?))]
      zloc)))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/leftmost
      j/node)
  # =>
  :a

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/rightmost
      j/leftmost
      j/node)
  # =>
  :a

  )

(defn j/path
  "Returns the path of nodes that lead to `zloc` from the root node."
  [zloc]
  (when-let [st (j/state zloc)]
    (get st :pnodes)))

(comment

  (j/path (j/ds-zip [:a :b [:x :y]]))
  # =>
  nil

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/path)
  # =>
  [[:a :b [:x :y]]]

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/right
      j/right
      j/down
      j/path)
  # =>
  [[:a :b [:x :y]] [:x :y]]

  )

(defn j/right-until
  ``
  Try to move right from `zloc`, calling `pred` for each
  right sibling.  If the `pred` call has a truthy result,
  return the corresponding right sibling.
  Otherwise, return nil.
  ``
  [zloc pred]
  (when-let [right-sib (j/right zloc)]
    (if (pred right-sib)
      right-sib
      (j/right-until right-sib pred))))

(comment

  (-> [:code
       [:tuple
        [:comment "# hi there"] [:whitespace "\n"]
        [:symbol "+"] [:whitespace " "]
        [:number "1"] [:whitespace " "]
        [:number "2"]]]
      j/ds-zip
      j/down
      j/right
      j/down
      (j/right-until |(match (j/node $)
                      [:comment]
                      false
                      #
                      [:whitespace]
                      false
                      #
                      true))
      j/node)
  # =>
  [:symbol "+"]

  )

(defn j/left-until
  ``
  Try to move left from `zloc`, calling `pred` for each
  left sibling.  If the `pred` call has a truthy result,
  return the corresponding left sibling.
  Otherwise, return nil.
  ``
  [zloc pred]
  (when-let [left-sib (j/left zloc)]
    (if (pred left-sib)
      left-sib
      (j/left-until left-sib pred))))

(comment

  (-> [:code
       [:tuple
        [:comment "# hi there"] [:whitespace "\n"]
        [:symbol "+"] [:whitespace " "]
        [:number "1"] [:whitespace " "]
        [:number "2"]]]
      j/ds-zip
      j/down
      j/right
      j/down
      j/rightmost
      (j/left-until |(match (j/node $)
                     [:comment]
                     false
                     #
                     [:whitespace]
                     false
                     #
                     true))
      j/node)
  # =>
  [:number "1"]

  )

(defn j/search-from
  ``
  Successively call `pred` on z-locations starting at `zloc`
  in depth-first order.  If a call to `pred` returns a
  truthy value, return the corresponding z-location.
  Otherwise, return nil.
  ``
  [zloc pred]
  (if (pred zloc)
    zloc
    (when-let [next-zloc (j/df-next zloc)]
      (when (j/end? next-zloc)
        (break nil))
      (j/search-from next-zloc pred))))

(comment

  (-> (j/ds-zip [:a :b :c])
      j/down
      (j/search-from |(match (j/node $)
                      :b
                      true))
      j/node)
  # =>
  :b

  (-> (j/ds-zip [:a :b :c])
      j/down
      (j/search-from |(match (j/node $)
                      :d
                      true)))
  # =>
  nil

  (-> (j/ds-zip [:a :b :c])
      j/down
      (j/search-from |(match (j/node $)
                      :a
                      true))
      j/node)
  # =>
  :a

  )

(defn j/search-after
  ``
  Successively call `pred` on z-locations starting after
  `zloc` in depth-first order.  If a call to `pred` returns a
  truthy value, return the corresponding z-location.
  Otherwise, return nil.
  ``
  [zloc pred]
  (when (j/end? zloc)
    (break nil))
  (when-let [next-zloc (j/df-next zloc)]
    (if (pred next-zloc)
      next-zloc
      (j/search-after next-zloc pred))))

(comment

  (-> (j/ds-zip [:b :a :b])
      j/down
      (j/search-after |(match (j/node $)
                       :b
                       true))
      j/left
      j/node)
  # =>
  :a

  (-> (j/ds-zip [:b :a :b])
      j/down
      (j/search-after |(match (j/node $)
                       :d
                       true)))
  # =>
  nil

  (-> (j/ds-zip [:a [:b :c [2 [3 :smile] 5]]])
      (j/search-after |(match (j/node $)
                       [_ :smile]
                       true))
      j/down
      j/node)
  # =>
  3

  )

(defn j/unwrap
  ``
  If the node at `zloc` is a branch node, "unwrap" its children in
  place.  If `zloc`'s node is not a branch node, do nothing.

  Throws an error if `zloc` corresponds to a top-most container.
  ``
  [zloc]
  (unless (j/branch? zloc)
    (break zloc))
  #
  (when (empty? (j/state zloc))
    (error "Called `unwrap` at root"))
  #
  (def kids (j/children zloc))
  (var i (dec (length kids)))
  (var curr-zloc zloc)
  (while (<= 0 i) # right to left
    (set curr-zloc
         (j/insert-right curr-zloc (get kids i)))
    (-- i))
  # try to end up at a sensible spot
  (set curr-zloc
       (j/remove curr-zloc))
  (if-let [ret-zloc (j/right curr-zloc)]
    ret-zloc
    curr-zloc))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/right
      j/right
      j/unwrap
      j/root)
  # =>
  [:a :b :x :y]

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/unwrap
      j/root)
  # =>
  [:a :b [:x :y]]

  (-> (j/ds-zip [[:a]])
      j/down
      j/unwrap
      j/root)
  # =>
  [:a]

  (-> (j/ds-zip [[:a :b] [:x :y]])
      j/down
      j/down
      j/remove
      j/unwrap
      j/root)
  # =>
  [:b [:x :y]]

  (try
    (-> (j/ds-zip [:a :b [:x :y]])
        j/unwrap)
    ([e] e))
  # =>
  "Called `unwrap` at root"

  )

(defn j/wrap
  ``
  Replace nodes from `start-zloc` through `end-zloc` with a single
  node of the same type as `wrap-node` containing the nodes from
  `start-zloc` through `end-zloc`.

  If `end-zloc` is not specified, just wrap `start-zloc`.

  The caller is responsible for ensuring the value of `end-zloc`
  is somewhere to the right of `start-zloc`.  Throws an error if
  an inappropriate value is specified for `end-zloc`.
  ``
  [start-zloc wrap-node &opt end-zloc]
  (default end-zloc start-zloc)
  #
  # 1. collect all nodes to wrap
  #
  (def kids @[])
  (var cur-zloc start-zloc)
  (while (and cur-zloc
              # XXX: expensive?
              (not (deep= (j/node cur-zloc)
                          (j/node end-zloc)))) # left to right
    (array/push kids (j/node cur-zloc))
    (set cur-zloc (j/right cur-zloc)))
  (when (nil? cur-zloc)
    (error "Called `wrap` with invalid value for `end-zloc`."))
  # also collect the last node
  (array/push kids (j/node end-zloc))
  #
  # 2. replace locations that will be removed with non-container nodes
  #
  (def dummy-node
    (j/make-node start-zloc wrap-node (tuple)))
  (set cur-zloc start-zloc)
  # trying to do this together in step 1 is not straight-forward
  # because the desired exiting condition for the while loop depends
  # on cur-zloc becoming end-zloc -- if `replace` were to be used
  # there, the termination condition never gets fulfilled properly.
  (for i 0 (dec (length kids)) # left to right again
    (set cur-zloc
         (-> (j/replace cur-zloc dummy-node)
             j/right)))
  (set cur-zloc
       (j/replace cur-zloc dummy-node))
  #
  # 3. remove all relevant locations
  #
  (def new-node
    (j/make-node start-zloc wrap-node (tuple ;kids)))
  (for i 0 (dec (length kids)) # right to left
    (set cur-zloc
         (j/remove cur-zloc)))
  # 4. put the new container node into place
  (j/replace cur-zloc new-node))

(comment

  (def start-zloc
    (-> (j/ds-zip [:a [:b] :c :x])
        j/down
        j/right))

  (j/node start-zloc)
  # =>
  [:b]

  (-> (j/wrap start-zloc [])
      j/root)
  # =>
  [:a [[:b]] :c :x]

  (def end-zloc
    (j/right start-zloc))

  (j/node end-zloc)
  # =>
  :c

  (-> (j/wrap start-zloc [] end-zloc)
      j/root)
  # =>
  [:a [[:b] :c] :x]

  (try
    (-> (j/wrap end-zloc [] start-zloc)
        j/root)
    ([e] e))
  # =>
  "Called `wrap` with invalid value for `end-zloc`."

  )

########################################################################

(defn j/has-children?
  ``
  Returns true if `a-node` can have children.
  Returns false if `a-node` cannot have children.
  ``
  [a-node]
  (when-let [[head] a-node]
    (truthy? (get {:code true
                   :fn true
                   :quasiquote true
                   :quote true
                   :splice true
                   :unquote true
                   :array true
                   :tuple true
                   :bracket-array true
                   :bracket-tuple true
                   :table true
                   :struct true}
                  head))))

(comment

  (j/has-children?
    [:tuple @{}
     [:symbol @{} "+"] [:whitespace @{} " "]
     [:number @{} "1"] [:whitespace @{} " "]
     [:number @{} "2"]])
  # =>
  true

  (j/has-children? [:number @{} "8"])
  # =>
  false

  )

(defn j/zip
  ``
  Returns a zipper location (zloc or z-location) for a tree
  representing Janet code.
  ``
  [a-tree]
  (defn branch?_
    [a-node]
    (truthy? (and (indexed? a-node)
                  (not (empty? a-node))
                  (j/has-children? a-node))))
  #
  (defn children_
    [a-node]
    (if (branch?_ a-node)
      (slice a-node 2)
      (error "Called `children` on a non-branch node")))
  #
  (defn make-node_
    [a-node kids]
    [(first a-node) (get a-node 1) ;kids])
  #
  (j/zipper a-tree branch?_ children_ make-node_))

(comment

  (def root-node
    @[:code @{} [:number @{} "8"]])

  (def [the-node the-state]
    (j/zip root-node))

  the-node
  # =>
  root-node

  # merge is used to "remove" the prototype table of `st`
  (merge {} the-state)
  # =>
  @{}

  )

(defn j/attrs
  ``
  Return the attributes table for the node of a z-location.  The
  attributes table contains at least bounds of the node by 1-based line
  and column numbers.
  ``
  [zloc]
  (get (j/node zloc) 1))

(comment

  (-> (j/par "(+ 1 3)")
      j/zip
      j/down
      j/attrs)
  # =>
  @{:bc 1 :bl 1 :ec 8 :el 1}

  )

(defn j/zip-down
  ``
  Convenience function that returns a zipper which has
  already had `down` called on it.
  ``
  [a-tree]
  (-> (j/zip a-tree)
      j/down))

(comment

  (-> (j/par "(+ 1 3)")
      j/zip-down
      j/node)
  # =>
  [:tuple @{:bc 1 :bl 1 :ec 8 :el 1}
   [:symbol @{:bc 2 :bl 1 :ec 3 :el 1} "+"]
   [:whitespace @{:bc 3 :bl 1 :ec 4 :el 1} " "]
   [:number @{:bc 4 :bl 1 :ec 5 :el 1} "1"]
   [:whitespace @{:bc 5 :bl 1 :ec 6 :el 1} " "]
   [:number @{:bc 6 :bl 1 :ec 7 :el 1} "3"]]

  (-> (j/par "(/ 1 8)")
      j/zip-down
      j/root)
  # =>
  @[:code @{:bc 1 :bl 1 :ec 8 :el 1}
    [:tuple @{:bc 1 :bl 1 :ec 8 :el 1}
            [:symbol @{:bc 2 :bl 1 :ec 3 :el 1} "/"]
            [:whitespace @{:bc 3 :bl 1 :ec 4 :el 1} " "]
            [:number @{:bc 4 :bl 1 :ec 5 :el 1} "1"]
            [:whitespace @{:bc 5 :bl 1 :ec 6 :el 1} " "]
            [:number @{:bc 6 :bl 1 :ec 7 :el 1} "8"]]]

  )

# wsc == whitespace, comment
(defn j/right-skip-wsc
  ``
  Try to move right from `zloc`, skipping over whitespace
  and comment nodes.

  When at least one right move succeeds, return the z-location
  for the last successful right move destination.  Otherwise,
  return nil.
  ``
  [zloc]
  (j/right-until zloc
               |(match (j/node $)
                  [:whitespace]
                  false
                  #
                  [:comment]
                  false
                  #
                  true)))

(comment

  (-> (j/par (string "(# hi there\n"
                   "+ 1 2)"))
      j/zip-down
      j/down
      j/right-skip-wsc
      j/node)
  # =>
  [:symbol @{:bc 1 :bl 2 :ec 2 :el 2} "+"]

  (-> (j/par "(:a)")
      j/zip-down
      j/down
      j/right-skip-wsc)
  # =>
  nil

  )

(defn j/left-skip-wsc
  ``
  Try to move left from `zloc`, skipping over whitespace
  and comment nodes.

  When at least one left move succeeds, return the z-location
  for the last successful left move destination.  Otherwise,
  return nil.
  ``
  [zloc]
  (j/left-until zloc
              |(match (j/node $)
                 [:whitespace]
                 false
                 #
                 [:comment]
                 false
                 #
                 true)))

(comment

  (-> (j/par (string "(# hi there\n"
                   "+ 1 2)"))
      j/zip-down
      j/down
      j/right-skip-wsc
      j/right-skip-wsc
      j/left-skip-wsc
      j/node)
  # =>
  [:symbol @{:bc 1 :bl 2 :ec 2 :el 2} "+"]

  (-> (j/par "(:a)")
      j/zip-down
      j/down
      j/left-skip-wsc)
  # =>
  nil

  )

# ws == whitespace
(defn j/right-skip-ws
  ``
  Try to move right from `zloc`, skipping over whitespace
  nodes.

  When at least one right move succeeds, return the z-location
  for the last successful right move destination.  Otherwise,
  return nil.
  ``
  [zloc]
  (j/right-until zloc
               |(match (j/node $)
                  [:whitespace]
                  false
                  #
                  true)))

(comment

  (-> (j/par (string "( # hi there\n"
                   "+ 1 2)"))
      j/zip-down
      j/down
      j/right-skip-ws
      j/node)
  # =>
  [:comment @{:bc 3 :bl 1 :ec 13 :el 1} "# hi there"]

  (-> (j/par "(:a)")
      j/zip-down
      j/down
      j/right-skip-ws)
  # =>
  nil

  )

(defn j/left-skip-ws
  ``
  Try to move left from `zloc`, skipping over whitespace
  nodes.

  When at least one left move succeeds, return the z-location
  for the last successful left move destination.  Otherwise,
  return nil.
  ``
  [zloc]
  (j/left-until zloc
              |(match (j/node $)
                 [:whitespace]
                 false
                 #
                 true)))

(comment

  (-> (j/par (string "(# hi there\n"
                   "+ 1 2)"))
      j/zip-down
      j/down
      j/right
      j/right
      j/left-skip-ws
      j/node)
  # =>
  [:comment @{:bc 2 :bl 1 :ec 12 :el 1} "# hi there"]

  (-> (j/par "(:a)")
      j/zip-down
      j/down
      j/left-skip-ws)
  # =>
  nil

  )


(comment import ./random :prefix "")


(defn p/dprintf
  [fmt & args]
  (when (os/getenv "VERBOSE")
    (eprintf fmt ;args)))

# XXX: does not have integers, strings, structs, and alias for repeat
# XXX: hard-wiring -- is there a better way?
(def p/specials
  (tabseq [k :in ['! '$ '% '* '+ '-> '/ '<- '> '? '??
                  'accumulate 'any 'argument 'at-least 'at-most
                  'backmatch 'backref 'between
                  'capture 'choice 'cmt 'cms 'column 'constant
                  'debug 'drop
                  'error
                  'group
                  'if 'if-not 'int 'int-be
                  'lenprefix 'line 'look
                  'not 'nth 'number
                  'opt 'only-tags
                  'position
                  'quote
                  'range 'repeat 'replace
                  'sequence 'set 'some 'split 'sub
                  'thru 'til 'to
                  'uint 'uint-be 'unref]]
    (string k) true))

# XXX: outline
#
# * (rewrite-test test-zloc)
#   * (find-peg-match-call test-zloc)
#     * (rewrite-peg-match-call peg-match-zloc)
#       * (find-grammar-argument peg-match-zloc)
#         * (find-peg-specials grammar-zloc)
#           * (choose-peg-special peg-special-zlocs)
#             * (blank-peg-special peg-special-zloc)

# XXX: list cases not handled
#
#      * integer (handled in find-peg-specials)
#      * keyword (handled in find-peg-specials)
#      * string long-string (handled in find-peg-specials)
#      * constant (handled in find-peg-specials)
#      * other?
(defn p/is-peg-special?
  [a-sym]
  (get p/specials a-sym))

# XXX: might be issues with cmt and replace -- could rethink as
#      "what to blank" instead of just looking for peg specials
(defn p/find-peg-specials
  [grammar-zloc]
  (def results @[])
  # compare against this to determine whether still a descendant
  (def grammar-path-len
    (length (j/path grammar-zloc)))
  (var curr-zloc grammar-zloc)
  (while (not (j/end? curr-zloc))
    (match (j/node curr-zloc)
      [:symbol _ content]
      (when (p/is-peg-special? content)
        (array/push results curr-zloc))
      [:number]
      (array/push results curr-zloc)
      [:keyword]
      (array/push results curr-zloc)
      [:constant]
      (array/push results curr-zloc)
      [:string]
      (array/push results curr-zloc)
      [:long-string]
      (array/push results curr-zloc))
    (set curr-zloc
         (j/df-next curr-zloc))
    # XXX: not 100% sure whether this is something that can be relied on
    (when (or (j/end? curr-zloc)
              # no longer a descendant of grammar-zloc
              # XXX: verify relying on this is solid
              (<= (length (j/path curr-zloc))
                  grammar-path-len))
      (break)))
  #
  results)

(comment

  (def src
    ``
    ~(sequence "#"
               (capture (to "=>"))
               "=>"
               (capture (thru -1)))
    ``)

  (map |(j/node $)
       (p/find-peg-specials (-> (l/par src)
                              j/zip-down)))
  # =>
  '@[(:symbol @{:bc 3 :bl 1 :ec 11 :el 1} "sequence")
     (:string @{:bc 12 :bl 1 :ec 15 :el 1} "\"#\"")
     (:symbol @{:bc 13 :bl 2 :ec 20 :el 2} "capture")
     (:symbol @{:bc 22 :bl 2 :ec 24 :el 2} "to")
     (:string @{:bc 25 :bl 2 :ec 29 :el 2} "\"=>\"")
     (:string @{:bc 12 :bl 3 :ec 16 :el 3} "\"=>\"")
     (:symbol @{:bc 13 :bl 4 :ec 20 :el 4} "capture")
     (:symbol @{:bc 22 :bl 4 :ec 26 :el 4} "thru")
     (:number @{:bc 27 :bl 4 :ec 29 :el 4} "-1")]

  )

(defn p/blank-peg-special
  [peg-special-zloc]
  (def node-type
    (get (j/node peg-special-zloc) 0))
  (var blanked-item nil)
  (var new-peg-special-zloc nil)
  (cond
    (or (= :symbol node-type)
        (= :constant node-type)
        (= :number node-type)
        (= :string node-type)
        (= :long-string node-type)
        (= :keyword node-type))
    (set new-peg-special-zloc
         (j/edit peg-special-zloc
                 |(let [original-item (get $ 2)]
                    (set blanked-item original-item)
                    [node-type
                     (get $ 1)
                     (string/repeat "_" (length original-item))])))
    #
    (do
      (eprintf "Unexpected node-type: %s" node-type)
      (set new-peg-special-zloc peg-special-zloc)))
  [new-peg-special-zloc blanked-item])

(comment

    (def src
    ``
    ~(sequence "#"
               (capture (to "=>"))
               "=>"
               (capture (thru -1)))
    ``)

  (def ps-zloc
    (first (p/find-peg-specials (-> (l/par src)
                                  j/zip-down))))

  (def [new-peg-special blanked-item]
    (p/blank-peg-special ps-zloc))

  (j/node new-peg-special)
  # =>
  [:symbol @{:bc 3 :bl 1 :ec 11 :el 1} "________"]

  blanked-item
  # =>
  "sequence"

  (->> (p/blank-peg-special ps-zloc)
       first
       j/root
       l/gen)
  # =>
  ``
  ~(________ "#"
             (capture (to "=>"))
             "=>"
             (capture (thru -1)))
  ``

  )

(defn p/find-grammar-argument
  [peg-match-call-zloc]
  (when-let [pm-sym-zloc
             (j/search-from peg-match-call-zloc
                            |(match (j/node $)
                               [:symbol _ "peg/match"]
                               true))]
    # this should be the first argument
    (j/right-skip-wsc pm-sym-zloc)))

(comment

  (def src
    ``
    (peg/match ~(capture (range "09"))
               "123")
    ``)

  (j/node (p/find-grammar-argument (->> (l/par src)
                                      j/zip-down)))
  # =>
  '(:quasiquote
     @{:bc 12 :bl 1 :ec 35 :el 1}
     (:tuple @{:bc 13 :bl 1 :ec 35 :el 1}
             (:symbol @{:bc 14 :bl 1 :ec 21 :el 1} "capture")
             (:whitespace @{:bc 21 :bl 1 :ec 22 :el 1} " ")
             (:tuple @{:bc 22 :bl 1 :ec 34 :el 1}
                     (:symbol @{:bc 23 :bl 1 :ec 28 :el 1} "range")
                     (:whitespace @{:bc 28 :bl 1 :ec 29 :el 1} " ")
                     (:string @{:bc 29 :bl 1 :ec 33 :el 1} "\"09\""))))

  )

# XXX: not perfect but close enough?
(defn p/find-peg-match-call
  [test-zloc]
  (when-let [pm-sym-zloc
             (j/search-from test-zloc
                            |(match (j/node $)
                               [:symbol _ "peg/match"]
                               true))]
    # this should be the tuple the peg/match symbol is a child of
    (j/up pm-sym-zloc)))

(comment

  (def src
    ``
    (try
      (peg/match ~(error (capture "a"))
                 "a")
      ([e] e))
    ``)

  (j/node (p/find-peg-match-call (->> (l/par src)
                                    j/zip-down)))
  # ->
  '(:tuple
     @{:bc 3 :bl 2 :ec 18 :el 3}
     (:symbol @{:bc 4 :bl 2 :ec 13 :el 2} "peg/match")
     (:whitespace @{:bc 13 :bl 2 :ec 14 :el 2} " ")
     (:quasiquote @{:bc 14 :bl 2 :ec 36 :el 2}
                  (:tuple @{:bc 15 :bl 2 :ec 36 :el 2}
                          (:symbol @{:bc 16 :bl 2 :ec 21 :el 2} "error")
                          (:whitespace @{:bc 21 :bl 2 :ec 22 :el 2} " ")
                          (:tuple @{:bc 22 :bl 2 :ec 35 :el 2}
                                  (:symbol @{:bc 23 :bl 2 :ec 30 :el 2}
                                           "capture")
                                  (:whitespace @{:bc 30 :bl 2 :ec 31 :el 2}
                                               " ")
                                  (:string @{:bc 31 :bl 2 :ec 34 :el 2}
                                           "\"a\""))))
     (:whitespace @{:bc 36 :bl 2 :ec 1 :el 3} "\n")
     (:whitespace @{:bc 1 :bl 3 :ec 14 :el 3} "             ")
     (:string @{:bc 14 :bl 3 :ec 17 :el 3} "\"a\""))

  (def src
    ``
    (peg/match ~(if 1 "a")
               "a")
    ``)

  (j/node (p/find-peg-match-call (->> (l/par src)
                                    j/zip-down)))
  # =>
  '(:tuple
     @{:bc 1 :bl 1 :ec 16 :el 2}
     (:symbol @{:bc 2 :bl 1 :ec 11 :el 1} "peg/match")
     (:whitespace @{:bc 11 :bl 1 :ec 12 :el 1} " ")
     (:quasiquote @{:bc 12 :bl 1 :ec 23 :el 1}
                  (:tuple @{:bc 13 :bl 1 :ec 23 :el 1}
                          (:symbol @{:bc 14 :bl 1 :ec 16 :el 1} "if")
                          (:whitespace @{:bc 16 :bl 1 :ec 17 :el 1} " ")
                          (:number @{:bc 17 :bl 1 :ec 18 :el 1} "1")
                          (:whitespace @{:bc 18 :bl 1 :ec 19 :el 1} " ")
                          (:string @{:bc 19 :bl 1 :ec 22 :el 1} "\"a\"")))
     (:whitespace @{:bc 23 :bl 1 :ec 1 :el 2} "\n")
     (:whitespace @{:bc 1 :bl 2 :ec 12 :el 2} "           ")
     (:string @{:bc 12 :bl 2 :ec 15 :el 2} "\"a\""))

  )

(defn p/rewrite-test-zloc
  [test-zloc]
  # XXX: why is this printing a function...
  (p/dprintf "%M" j/path)
  (when-let [pm-call-zloc
             (p/find-peg-match-call test-zloc)
             grammar-zloc
             (p/find-grammar-argument pm-call-zloc)]
    (p/dprintf "test:")
    (p/dprintf (l/gen (j/node test-zloc)))
    (p/dprintf "grammar:")
    (p/dprintf (l/gen (j/node grammar-zloc)))
    # find how many "steps" back are needed to "get back" to original spot
    (var steps 0)
    (var chosen-special-zloc nil)
    # XXX: better to factor out so it can be recursive?
    (def grammar-node-type
      (get (j/node grammar-zloc) 0))
    (cond
      (or (= :string grammar-node-type)
          (= :long-string grammar-node-type)
          (= :keyword grammar-node-type)
          (= :constant grammar-node-type)
          (= :number grammar-node-type))
      (do
        (p/dprintf "grammar was a %s" grammar-node-type)
        (set chosen-special-zloc grammar-zloc))
      #
      (get {:tuple true
            :bracket-tuple true
            :quote true
            :quasiquote true
            :splice true
            :struct true
            :table true} grammar-node-type)
      (let [p/specials (p/find-peg-specials grammar-zloc)]
        # XXX
        (p/dprintf "grammar was a %s" grammar-node-type)
        # XXX
        (p/dprintf "Number of specials found: %d" (length p/specials))
        (when (empty? p/specials)
          # XXX
          (eprint "Failed to find a special")
          (break [nil nil]))
        (each sp p/specials
          (p/dprintf (l/gen (j/node sp))))
        (set chosen-special-zloc
             (rnd/choose p/specials))
        (p/dprintf "chosen: %s" (l/gen (j/node chosen-special-zloc))))
      #
      (do
        (eprint "Unexpected node-type:" grammar-node-type)
        (break [nil nil])))
    # find how many steps away we are from test-zloc's node
    (var curr-zloc chosen-special-zloc)
    # XXX: compare (attrs ...) results instead of gen / node
    (def test-str
      (l/gen (j/node test-zloc)))
    (while curr-zloc
      # XXX: expensive?
      # XXX: compare (attrs ...) results instead -- should be faster
      #      attrs should be unique inside the tree(?)
      (when (= (l/gen (j/node curr-zloc))
               test-str)
        (break))
      (set curr-zloc
           (j/df-prev curr-zloc))
      (++ steps))
    # XXX
    (p/dprintf "steps: %d" steps)
    # XXX: check not nil?
    (var [curr-zloc blanked-item]
      (->> chosen-special-zloc
           p/blank-peg-special))
    # get back to "test-zloc" position
    (for i 0 steps
      (set curr-zloc
           (j/df-prev curr-zloc)))
    # XXX
    #(dprintf "curr-zloc: %M" curr-zloc)
    #
    [curr-zloc blanked-item]))

(defn p/rewrite-test
  [test-zloc]
  (when-let [[rewritten-zloc blanked-item]
             (p/rewrite-test-zloc test-zloc)]
    [(->> rewritten-zloc
         j/root
         l/gen)
     blanked-item]))

(comment

  (def src
    ``
    (try
      (peg/match ~(error (capture "a"))
                 "a")
      ([e] e))
    ``)

  (def [result blanked-item]
    (p/rewrite-test (->> (l/par src)
                       j/zip-down)))

  (or (= "error" blanked-item)
      (= "\"a\"" blanked-item)
      (= "capture" blanked-item))
  # =>
  true

  (or (= result
         ``
         (try
           (peg/match ~(error (_______ "a"))
                      "a")
           ([e] e))
         ``)
      (= result
         ``
         (try
           (peg/match ~(_____ (capture "a"))
                      "a")
           ([e] e))
         ``)
      (= result
         ``
         (try
           (peg/match ~(error (capture ___))
                      "a")
           ([e] e))
         ``)
      (= result
         ``
         (try
           (peg/match ~(error (capture "a"))
                      ___)
           ([e] e))
         ``))
  # =>
  true

  )

# ti == test indicator, which can look like any of:
#
# # =>
# # before =>
# # => after
# # before => after

(defn p/find-test-indicator
  [zloc]
  (var label-left nil)
  (var label-right nil)
  [(j/right-until zloc
                  |(match (j/node $)
                     [:comment _ content]
                     (if-let [[l r]
                              (peg/match ~(sequence "#"
                                                    (capture (to "=>"))
                                                    "=>"
                                                    (capture (thru -1)))
                                         content)]
                       (do
                         (set label-left (string/trim l))
                         (set label-right (string/trim r))
                         true)
                       false)))
   label-left
   label-right])

(comment

  (def src
    ``
    (+ 1 1)
    # =>
    2
    ``)

  (let [[zloc l r]
        (p/find-test-indicator (-> (l/par src)
                                 j/zip-down))]
    (and zloc
         (empty? l)
         (empty? r)))
  # =>
  true

  (def src
    ``
    (+ 1 1)
    # before =>
    2
    ``)

  (let [[zloc l r]
        (p/find-test-indicator (-> (l/par src)
                                 j/zip-down))]
    (and zloc
         (= "before" l)
         (empty? r)))
  # =>
  true

  (def src
    ``
    (+ 1 1)
    # => after
    2
    ``)

  (let [[zloc l r]
        (p/find-test-indicator (-> (l/par src)
                                 j/zip-down))]
    (and zloc
         (empty? l)
         (= "after" r)))
  # =>
  true

  )

(defn p/find-test-expr
  [ti-zloc]
  # check for appropriate conditions "before"
  (def before-zlocs @[])
  (var curr-zloc ti-zloc)
  (var found-before nil)
  (while curr-zloc
    (set curr-zloc
         (j/left curr-zloc))
    (when (nil? curr-zloc)
      (break))
    (match (j/node curr-zloc)
      [:comment]
      (array/push before-zlocs curr-zloc)
      #
      [:whitespace]
      (array/push before-zlocs curr-zloc)
      #
      (do
        (set found-before true)
        (array/push before-zlocs curr-zloc)
        (break))))
  #
  (cond
    (nil? curr-zloc)
    :no-test-expression
    #
    (and found-before
         (->> (slice before-zlocs 0 -2)
              (filter |(not (match (j/node $)
                              [:whitespace]
                              true)))
              length
              zero?))
    curr-zloc
    #
    :unexpected-result))

(comment

  (def src
    ``
    (comment

      (def a 1)

      (put @{} :a 2)
      # =>
      @{:a 2}

      )
    ``)

  (def [ti-zloc _ _]
    (p/find-test-indicator (-> (l/par src)
                             j/zip-down
                             j/down)))

  (j/node ti-zloc)
  # =>
  '(:comment @{:bc 3 :bl 6 :ec 7 :el 6} "# =>")

  (def test-expr-zloc
    (p/find-test-expr ti-zloc))

  (j/node test-expr-zloc)
  # =>
  '(:tuple @{:bc 3 :bl 5 :ec 17 :el 5}
           (:symbol @{:bc 4 :bl 5 :ec 7 :el 5} "put")
           (:whitespace @{:bc 7 :bl 5 :ec 8 :el 5} " ")
           (:table @{:bc 8 :bl 5 :ec 11 :el 5})
           (:whitespace @{:bc 11 :bl 5 :ec 12 :el 5} " ")
           (:keyword @{:bc 12 :bl 5 :ec 14 :el 5} ":a")
           (:whitespace @{:bc 14 :bl 5 :ec 15 :el 5} " ")
           (:number @{:bc 15 :bl 5 :ec 16 :el 5} "2"))

  (-> (j/left test-expr-zloc)
      j/node)
  # =>
  '(:whitespace @{:bc 1 :bl 5 :ec 3 :el 5} "  ")

  )

(defn p/find-expected-expr
  [ti-zloc]
  (def after-zlocs @[])
  (var curr-zloc ti-zloc)
  (var found-comment nil)
  (var found-after nil)
  #
  (while curr-zloc
    (set curr-zloc
         (j/right curr-zloc))
    (when (nil? curr-zloc)
      (break))
    (match (j/node curr-zloc)
      [:comment]
      (do
        (set found-comment true)
        (break))
      #
      [:whitespace]
      (array/push after-zlocs curr-zloc)
      #
      (do
        (set found-after true)
        (array/push after-zlocs curr-zloc)
        (break))))
  #
  (cond
    (or (nil? curr-zloc)
        found-comment)
    :no-expected-expression
    #
    (and found-after
         (match (j/node (first after-zlocs))
           [:whitespace _ "\n"]
           true))
    (if-let [from-next-line (drop 1 after-zlocs)
             next-line (take-until |(match (j/node $)
                                      [:whitespace _ "\n"]
                                      true)
                                   from-next-line)
             target (->> next-line
                         (filter |(match (j/node $)
                                    [:whitespace]
                                    false
                                    #
                                    true))
                         first)]
      target
      :no-expected-expression)
    #
    :unexpected-result))

(comment

  (def src
    ``
    (comment

      (def a 1)

      (put @{} :a 2)
      # =>
      @{:a 2}

      )
    ``)

  (def [ti-zloc _ _]
    (p/find-test-indicator (-> (l/par src)
                             j/zip-down
                             j/down)))

  (j/node ti-zloc)
  # =>
  '(:comment @{:bc 3 :bl 6 :ec 7 :el 6} "# =>")

  (def expected-expr-zloc
    (p/find-expected-expr ti-zloc))

  (j/node expected-expr-zloc)
  # =>
  '(:table @{:bc 3 :bl 7 :ec 10 :el 7}
           (:keyword @{:bc 5 :bl 7 :ec 7 :el 7} ":a")
           (:whitespace @{:bc 7 :bl 7 :ec 8 :el 7} " ")
           (:number @{:bc 8 :bl 7 :ec 9 :el 7} "2"))

  (-> (j/left expected-expr-zloc)
      j/node)
  # =>
  '(:whitespace @{:bc 1 :bl 7 :ec 3 :el 7} "  ")

  (def src
    ``
    (comment

      (butlast @[:a :b :c])
      # => @[:a :b]

      (butlast [:a])
      # => []

    )
    ``)

  (def [ti-zloc _ _]
    (p/find-test-indicator (-> (l/par src)
                             j/zip-down
                             j/down)))

  (j/node ti-zloc)
  # =>
  '(:comment @{:bc 3 :bl 4 :ec 16 :el 4} "# => @[:a :b]")

  (p/find-expected-expr ti-zloc)
  # =>
  :no-expected-expression

  )

(defn p/find-test-exprs
  [ti-zloc]
  # look for a test expression
  (def test-expr-zloc
    (p/find-test-expr ti-zloc))
  (case test-expr-zloc
    :no-test-expression
    (break [nil nil])
    #
    :unexpected-result
    (errorf "unexpected result from `find-test-expr`: %p"
            test-expr-zloc))
  # look for an expected value expression
  (def expected-expr-zloc
    (p/find-expected-expr ti-zloc))
  (case expected-expr-zloc
    :no-expected-expression
    (break [test-expr-zloc nil])
    #
    :unexpected-result
    (errorf "unexpected result from `find-expected-expr`: %p"
            expected-expr-zloc))
  #
  [test-expr-zloc expected-expr-zloc])

# XXX: new content from here

(defn p/extract-tests-from-comment-zloc
  [comment-zloc]
  # move into comment block
  (var curr-zloc (j/down comment-zloc))
  (def tests @[])
  # process comment block content
  (while (not (j/end? curr-zloc))
    (def [ti-zloc label-left label-right]
      (p/find-test-indicator curr-zloc))
    (unless ti-zloc
      (break))
    (def [test-expr-zloc expected-expr-zloc]
      (p/find-test-exprs ti-zloc))
    # found a complete test
    (if (and test-expr-zloc
             expected-expr-zloc)
      (do
        (array/push tests [test-expr-zloc
                           expected-expr-zloc])
        (set curr-zloc
             (j/right expected-expr-zloc)))
      (set curr-zloc
           (j/right curr-zloc))))
  #
  tests)

(comment

  (def src
    ``
    (comment

      (def a 1)

      (put @{} :a 2)
      # left =>
      @{:a 2}

      (+ 1 1)
      # => right
      2

      )
    ``)

  (def tests
    (-> (l/par src)
        j/zip-down
        p/extract-tests-from-comment-zloc))

  (l/gen (j/node (get-in tests [0 0])))
  # =>
  "(put @{} :a 2)"

  (l/gen (j/node (get-in tests [0 1])))
  # =>
  "@{:a 2}"

  (l/gen (j/node (get-in tests [1 0])))
  # =>
  "(+ 1 1)"

  (l/gen (j/node (get-in tests [1 1])))
  # =>
  "2"

  )

(defn p/extract-test-zlocs
  [src]
  (var tests @[])
  (var curr-zloc
    (-> (l/par src)
        j/zip-down
        # XXX: leading newline is a hack to prevent very first thing
        #      from being a comment block
        (j/insert-left [:whitespace @{} "\n"])
        # XXX: once the newline is inserted, need to move to it
        j/left))
  #
  (while (not (j/end? curr-zloc))
    # try to find a top-level comment block
    (if-let [comment-zloc
             (j/right-until curr-zloc
                            |(match (j/node $)
                               [:tuple _ [:symbol _ "comment"]]
                               true))]
      (do
        (let [results (p/extract-tests-from-comment-zloc comment-zloc)]
          (unless (empty? results)
            (array/push tests ;results))
          (set curr-zloc comment-zloc)))
      (break)))
  #
  tests)

(comment

  (def src
    ``
    (comment

      (def a 1)

      (put @{}
           :a 2)
      # left =>
      @{:a 2}

      (+ 1 1)
      # => right
      2

      )

    (comment

      (string/slice "hallo" 1)
      # =>
      "allo"

      )
    ``)

  (def test-zlocs
    (p/extract-test-zlocs src))

  # XXX: the indentation for all lines after the first one is off by 2
  #      because all lines are indented by 2 within the comment form.
  #      the first part of the test (on the first line) is not
  #      indented because the first non-whitespace character is
  #      what is identified as the starting position
  (l/gen (j/node (get-in test-zlocs [0 0])))
  # =>
  ``
  (put @{}
         :a 2)
  ``

  (l/gen (j/node (get-in test-zlocs [0 1])))
  # =>
  "@{:a 2}"

  (l/gen (j/node (get-in test-zlocs [2 0])))
  # =>
  "(string/slice \"hallo\" 1)"

  (l/gen (j/node (get-in test-zlocs [2 1])))
  # =>
  "\"allo\""

  )

# XXX: not perfect, but mostly ok?
(defn p/get-indentation
  [a-zloc]
  (when-let [left-zloc (j/left a-zloc)]
    (let [[the-type _ content] (j/node left-zloc)]
      (when (= :whitespace the-type)
        # found indentation
        (when (empty? (string/trim content))
          # early return
          (break content)))))
  # no indentation
  "")

(comment

  (def src
    ``
    (comment

      (def a 1)

      (put @{} :a 2)
      # =>
      @{:a 2}

      )
    ``)

  (def [ti-zloc _ _]
    (p/find-test-indicator (-> (l/par src)
                             j/zip-down
                             j/down)))

  (p/get-indentation (p/find-test-expr ti-zloc))
  # =>
  "  "

  )

(defn p/indent-node-gen
  [a-zloc]
  (string (p/get-indentation a-zloc) (l/gen (j/node a-zloc))))

(defn p/extract-tests
  [src]
  (def test-zlocs
    (p/extract-test-zlocs src))
  (map |(let [[t-zloc e-zloc] $]
          [(p/indent-node-gen t-zloc)
           (p/indent-node-gen e-zloc)])
       test-zlocs))

# only operate on first comment form
(defn p/extract-first-test-set-zlocs
  [src]
  (var tests @[])
  (var curr-zloc
    (-> (l/par src)
        j/zip-down
        # XXX: leading newline is a hack to prevent very first thing
        #      from being a comment block
        (j/insert-left [:whitespace @{} "\n"])
        # XXX: once the newline is inserted, need to move to it
        j/left))
  #
  (while (not (j/end? curr-zloc))
    # try to find a top-level comment block
    (if-let [comment-zloc
             (j/right-until curr-zloc
                            |(match (j/node $)
                               [:tuple _ [:symbol _ "comment"]]
                               true))]
      (do
        (let [results (p/extract-tests-from-comment-zloc comment-zloc)]
          (unless (empty? results)
            (array/push tests ;results))
          (break)))
      (break)))
  #
  tests)

# only operate on first comment form
(defn p/extract-first-test-set
  [src]
  (def test-zlocs
    (p/extract-first-test-set-zlocs src))
  (map |(let [[t-zloc e-zloc] $]
          [(p/indent-node-gen t-zloc)
           (p/indent-node-gen e-zloc)])
       test-zlocs))


(comment import ./random :prefix "")


(defn s/print-nicely
  [expr-str]
  (let [buf (hl/colorize (indent/format expr-str))]
    (each line (string/split "\n" buf)
      (print line))))

(defn s/print-separator
  []
  ((dyn :pdoc-hl-prin) (string/repeat "#" (dyn :pdoc-width))
                       (dyn :pdoc-separator-color)))

(defn s/handle-eval-failure
  [resp e]
  (print "Sorry, failed to evaluate your answer.")
  (print)
  (print "The error I got was:")
  (print)
  (printf "%p" e)
  (print)
  (print "I tried to evaluate the following:")
  (print)
  (print resp))

(defn s/handle-plain-response
  [ans resp]
  (print)
  (print "My answer is:")
  (print)
  (s/print-nicely ans)
  (print)
  (print "Your answer is:")
  (print)
  (s/print-nicely resp)
  (print)
  (when (deep= ans resp)
    (print "Yay, our answers agree :)")
    (break true))
  (print "Our answers differ, but perhaps yours works too.")
  (print)
  (try
    (let [result (eval-string resp)
          evaled-ans (eval-string ans)]
      (if (deep= result evaled-ans)
        (do
          (printf "Nice, our answers both evaluate to: %M"
                  evaled-ans)
          true)
        (do
          (printf "Sorry, your answer evaluates to: %M" result)
          false)))
    ([e]
      (s/handle-eval-failure resp e)
      false)))

(defn s/handle-want-to-quit
  [buf]
  (when (empty? (string/trim buf))
    (print "Had enough?  Perhaps on another occasion then.")
    #
    true))

(defn s/validate-response
  [buf]
  (try
    (do
      (parse buf)
      (string/trim buf))
    ([e]
      (print)
      (printf "Sorry, I didn't understand your response: %s"
              (string/trim buf))
      (print)
      (print "I got the following error:")
      (print)
      (printf "%p" e)
      nil)))

(defn s/special-plain-quiz
  [content]
  # extract first set of tests from content
  (def tests
    (p/extract-first-test-set content))
  (when (empty? tests)
    (print "Sorry, didn't find any material to make a quiz from.")
    (break nil))
  # choose a question and answer pair
  (let [[ques ans] (rnd/choose tests)
        trimmed-ans (string/trim ans)]
    # show the question
    (s/print-nicely ques)
    (print "# =>")
    # ask for an answer
    (def buf
      (getline ""))
    (when (s/handle-want-to-quit buf)
      (break nil))
    # does the response make some sense?
    (def resp
      (s/validate-response buf))
    (unless resp
      (break nil))
    # improve perceptibility
    (print)
    (s/print-separator)
    (print)
    #
    (s/handle-plain-response trimmed-ans resp)))

(defn s/handle-fill-in-response
  [ques blank-ques blanked-item ans resp]
  (print)
  (print "One complete picture is: ")
  (print)
  (s/print-nicely ques)
  (print "# =>")
  (s/print-nicely ans)
  (print)
  (print "So one value that works is:")
  (print)
  (s/print-nicely blanked-item)
  (print)
  (print "Your answer is:")
  (print)
  (s/print-nicely resp)
  (print)
  (when (deep= blanked-item resp)
    (print "Yay, the answers agree :)")
    (break true))
  (print "Our answers differ, but perhaps yours works too.")
  (print)
  (let [indeces (string/find-all "_" blank-ques)
        head-idx (first indeces)
        tail-idx (last indeces)]
    # XXX: cheap method -- more accurate would be to use zippers
    (def resp-code
      (string (string/slice blank-ques 0 head-idx)
              resp
              (string/slice blank-ques (inc tail-idx))))
    (try
      (let [result (eval-string resp-code)
            evaled-ans (eval-string ans)]
        (if (deep= result evaled-ans)
          (do
            (printf "Nice, our answers both evaluate to: %M"
                    evaled-ans)
            true)
          (do
            (printf "Sorry, our answers evaluate differently.")
            (print)
            (printf "My answer evaluates to: %M" result)
            (print)
            (printf "Your answer evaluates to: %M" evaled-ans)
            false)))
      ([e]
        (s/handle-eval-failure resp-code e)
        false))))

(defn s/special-fill-in-quiz
  [content]
  # extract first set of tests from content
  (def test-zloc-pairs
    (p/extract-first-test-set-zlocs content))
  (when (empty? test-zloc-pairs)
    (print "Sorry, didn't find any material to make a quiz from.")
    (break nil))
  # choose a question and answer, then make a blanked question
  (let [[ques-zloc ans-zloc] (rnd/choose test-zloc-pairs)
        [blank-ques-zloc blanked-item] (p/rewrite-test-zloc ques-zloc)]
    # XXX: a cheap work-around...evidence of a deeper issue?
    (unless blank-ques-zloc
      (print "Sorry, drew a blank...take a deep breath and try again?")
      (break nil))
    (let [ques (p/indent-node-gen ques-zloc)
          blank-ques (p/indent-node-gen blank-ques-zloc)
          trimmed-ans (string/trim (p/indent-node-gen ans-zloc))]
      # show the question
      (s/print-nicely blank-ques)
      (print "# =>")
      (s/print-nicely trimmed-ans)
      (print)
      # ask for an answer
      (def buf
        (getline "What value could work in the blank? "))
      (when (s/handle-want-to-quit buf)
        (break nil))
      # does the response make some sense?
      (def resp
        (s/validate-response buf))
      (unless resp
        (break nil))
      # improve perceptibility
      (print)
      (s/print-separator)
      (print)
      #
      (s/handle-fill-in-response ques blank-ques blanked-item
                               trimmed-ans resp))))

(defn s/special-quiz
  [content]
  (def quiz-fn
    (rnd/choose [s/special-plain-quiz
                 s/special-fill-in-quiz]))
  (quiz-fn content))

########################################################################

# assumes example file has certain structure
(defn s/massage-lines-for-examples
  [lines]
  (def n-lines (length lines))
  (def m-lines @[])
  (var i 0)
  # skip first line if import
  (when (peg/match ~(sequence "(import")
                   (first lines))
    (++ i))
  # get "inside" comment form
  (while (< i n-lines)
    (def cur-line (get lines i))
    # whether loop ends or not, index increases
    (++ i)
    # stop at first (comment ...) form
    (when (peg/match ~(sequence "(comment")
                     cur-line)
      (break)))
  # save lines until (comment ...) ends
  (while (< i n-lines)
    (def cur-line (get lines i))
    # supposedly where the "(comment ...)" form ends -- hacky
    (if (peg/match ~(sequence (any (set " \t\f\v"))
                              ")")
                   cur-line)
      (break)
      (if (string/has-prefix? "  " cur-line)
        (array/push m-lines (string/slice cur-line 2))
        (array/push m-lines cur-line)))
    (++ i))
  #
  m-lines)

(defn s/special-usages
  [content]
  (def lines
    (string/split "\n" content))
  (def examples-lines
    (s/massage-lines-for-examples lines))
  (-> (string/join examples-lines "\n")
      hl/colorize
      print))


(comment import ./view :prefix "")
(comment import ./highlight :prefix "")

(comment import ./termsize :prefix "")


(defn view/configure
  []
  # width
  (def cols
    (if-let [cols (t/cols)]
      cols
      80))
  (setdyn :pdoc-width cols)
  # color
  (let [color-level (os/getenv "PDOC_COLOR")
        # XXX: tput colors more portable?
        color-term (os/getenv "COLORTERM")]
    # XXX: not ready for prime time, so insist PDOC_COLOR is
    #      set for anything to happen
    (if color-level
      (cond
        (or (= "rgb" color-level)
            #(= "truecolor" color-term)
            false)
        (do
          (setdyn :pdoc-hl-prin hl/rgb/rgb-prin)
          (setdyn :pdoc-hl-str hl/rgb/rgb-str)
          (setdyn :pdoc-separator-color hl/rgb/rgb-separator-color)
          (setdyn :pdoc-theme hl/rgb-theme))
        #
        (or (= "color" color-level)
            (= "16" color-term))
        (do
          (setdyn :pdoc-hl-prin hl/color/color-prin)
          (setdyn :pdoc-hl-str hl/color/color-str)
          (setdyn :pdoc-separator-color hl/color/color-separator-color)
          (setdyn :pdoc-theme hl/color-theme))
        #
        (do
          (setdyn :pdoc-hl-prin hl/m/mono-prin)
          (setdyn :pdoc-hl-str hl/m/mono-str)
          (setdyn :pdoc-separator-color hl/m/mono-separator-color)
          (setdyn :pdoc-theme hl/mono-theme)))
      # no color
      (do
        (setdyn :pdoc-hl-prin hl/m/mono-prin)
        (setdyn :pdoc-hl-str hl/m/mono-str)
        (setdyn :pdoc-separator-color hl/m/mono-separator-color)
        (setdyn :pdoc-theme hl/mono-theme)))))



(def version "2026-02-05_14-04-59")

(def usage
  ``
  Usage: pdoc [option] [peg-special]

  View Janet PEG information.

    -h, --help                   show this output

    -d, --doc [<peg-special>]    show doc
    -q, --quiz [<peg-special>]   show quiz question
    -u, --usage [<peg-special>]  show usage

    --bash-completion            output bash-completion bits
    --fish-completion            output fish-completion bits
    --zsh-completion             output zsh-completion bits
    --raw-all                    show all names for completion

  With a peg-special, but no options, show docs and usages.

  If any of "boolean", "dictionary", "integer", "string",
  "struct", or "table" are specified as the "peg-special",
  show docs and usages about using those as PEG constructs.

  With the `-d` or `--doc` option, show docs for specified
  PEG special, or if none specified, for a randomly chosen one.

  With the `-q` or `--quiz` option, show quiz question for
  specified PEG special, or if none specified, for a randomly
  chosen one.

  With the `-u` or `--usage` option, show usages for
  specified PEG special, or if none specified, for a randomly
  chosen one.

  With no arguments, lists all PEG specials.

  Be careful to quote shortnames (e.g. *, ->, >, <-, etc.)
  appropriately so the shell doesn't process them in an
  undesired fashion.
  ``)

(defn main
  [& argv]
  (setdyn :pdoc-rng
          (math/rng (os/cryptorand 8)))

  (view/configure)

  (def [opts rest errs]
    (av/parse-argv argv))

  (when (not (empty? errs))
    (each err errs
      (eprint "pdoc: " err))
    (eprint "Try 'pdoc -h' for usage text.")
    (os/exit 1))

  # usage
  (when (opts :help)
    (print usage)
    (os/exit 0))

  # possibly handle dumping completion bits
  (when (compl/maybe-handle-dump-completion opts)
    (os/exit 0))

  # help completion by showing a raw list of relevant names
  (when (opts :raw-all)
    (s/all-names data/names)
    (os/exit 0))

  # check if there was a peg special specified
  (def special (ex/get-special (first rest)))

  # if no peg-special found and no options, show info about all specials
  (when (and (nil? special)
             (nil? (opts :doc))
             (nil? (opts :usage))
             (nil? (opts :quiz)))
    (print ex/summary)
    (os/exit 0))

  # ensure a special-name beyond this form by choosing one if needed
  (default special (rnd/choose data/names))

  # show docs, usages, and/or quizzes for a special-fname
  (def content (ex/get-content special))

  (when (or (and (opts :doc) (opts :usage))
            (and (nil? (opts :doc))
                 (nil? (opts :usage))
                 (nil? (opts :quiz))))
    (s/special-doc content)
    ((dyn :pdoc-hl-prin) (string/repeat "#" (dyn :pdoc-width))
                         (dyn :pdoc-separator-color))
    (print)
    (s/special-usages content)
    (os/exit 0))

  (when (opts :doc)
    (s/special-doc content))

  (cond
    (opts :usage)
    (s/special-usages content)
    #
    (opts :quiz)
    (s/special-quiz content)))

